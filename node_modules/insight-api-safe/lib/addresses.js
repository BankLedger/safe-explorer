'use strict';

var bitcore = require('bitcore-lib-safe');
var async = require('async');
var TxController = require('./transactions');
var Common = require('./common');
var Decimal = require("decimal.js");

function AddressController(node) {
    this.node = node;
    this.txController = new TxController(node);
    this.common = new Common({log: this.node.log});
}

AddressController.prototype.show = function (req, res) {
    var self = this;
    var options = {
        noTxList: 0
    };
    if (!req.query.assetsId || req.query.assetsId == "all") {
        options.assetsId = "";
    } else {
        options.assetsId = req.query.assetsId;
    }
    if (req.query.from && req.query.to) {
        options.from = parseInt(req.query.from);
        options.to = parseInt(req.query.to);
    }
    self.getAddressSummary(req.addr, options, function (err, data) {
        if (err) {
            return self.common.handleErrors(err, res);
        }
        self.getAddressAssetsList(req.addr, function (err, assets) {
            if (err) {
                return self.common.handleErrors(err, res);
            }
            data.assets = assets;
            res.jsonp(data);
        })
    });
};

AddressController.prototype.balance = function (req, res) {
    this.addressSummarySubQuery(req, res, 'balanceSat');
};

AddressController.prototype.totalReceived = function (req, res) {
    this.addressSummarySubQuery(req, res, 'totalReceivedSat');
};

AddressController.prototype.totalSent = function (req, res) {
    this.addressSummarySubQuery(req, res, 'totalSentSat');
};

AddressController.prototype.unconfirmedBalance = function (req, res) {
    this.addressSummarySubQuery(req, res, 'unconfirmedBalanceSat');
};

AddressController.prototype.addressSummarySubQuery = function (req, res, param) {
    var self = this;
    this.getAddressSummary(req.addr, {}, function (err, data) {
        if (err) {
            return self.common.handleErrors(err, res);
        }
        res.jsonp(data[param]);
    });
};

AddressController.prototype.getAddressSummary = function (address, options, callback) {
    this.node.getAddressSummary(address, options, function (err, summary) {
        if (err) {
            return callback(err);
        }

        /**
         * 总接收 totalReceived  不计算
         * 总发送 totalSent   =  总接送 减去 总余额
         * 最终金额 available = 总接收 减去 总发送
         * 锁定金额 lock 不计算
         * 可用金额 balance   = 总接收 减去 总发送 减去 总锁定 减去封存
         */
        var totalSent = Decimal(summary.received).sub(summary.balance); //总发送

        var transformed = {
            addrStr: address,
            totalReceived: Decimal(summary.received),                   //总接收
            totalSent: totalSent,                                       //总发送
            available: Decimal(summary.received).sub(totalSent),        //总余额 不减去锁定
            lock: Decimal(summary.lock),                                //总锁定
            balance: Decimal(summary.received).sub(totalSent).sub(summary.lock),//.sub(summary.depositAmount),       //总可用
            depositAmount: summary.depositAmount,       //封存

            unconfirmedBalance: summary.unconfirmedBalance,
            unconfirmedTxApperances: summary.unconfirmedAppearances, // misspelling - ew
            txApperances: summary.appearances // yuck
        };
        callback(null, transformed);
    });
};

AddressController.prototype.getAddressAssetsList = function (address, callback) {
    var self = this;
    var assetNames = [];
    self.node.getAddressAssetList(address, function (err, assetIds) {
        if (err) {
            return callback(err);
        }
        async.eachSeries(assetIds, function (assetId, eachAssetIdsCB) {
            self.node.getAssetsObj(assetId, function (err, assetInfo) {
                if (err) {
                    return eachAssetIdsCB(err);
                }
                assetNames.push({
                    shortName: assetInfo.assetShortName,
                    assetId: assetId
                });
                eachAssetIdsCB(null)
            })
        }, function (err) {
            if (err) {
                return callback(err);
            }
            callback(null, assetNames);
        })
    })
};

AddressController.prototype.checkAddr = function (req, res, next) {
    req.addr = req.params.addr;
    this.check(req, res, next, [req.addr]);
};

AddressController.prototype.checkAddrs = function (req, res, next) {
    if (req.body.addrs) {
        req.addrs = req.body.addrs.split(',');
    } else {
        req.addrs = req.params.addrs.split(',');
    }

    this.check(req, res, next, req.addrs);
};

AddressController.prototype.check = function (req, res, next, addresses) {
    var self = this;
    if (!addresses.length || !addresses[0]) {
        return self.common.handleErrors({
            message: 'Must include address',
            code: 1
        }, res);
    }

    for (var i = 0; i < addresses.length; i++) {
        try {
            new bitcore.Address(addresses[i]);
        } catch (e) {
            return self.common.handleErrors({
                message: 'Invalid address: ' + e.message,
                code: 1
            }, res);
        }
    }

    next();
};

AddressController.prototype.utxo = function (req, res) {
    var self = this;
    this.node.getAddressUnspentOutputs(req.addr, {}, function (err, utxos) {
        if (err) {
            return self.common.handleErrors(err, res);
        } else if (!utxos.length) {
            return res.jsonp([]);
        }
        res.jsonp(utxos.map(self.transformUtxo.bind(self)));
    });
};

AddressController.prototype.multiutxo = function (req, res) {
    var self = this;
    this.node.getAddressUnspentOutputs(req.addrs, true, function (err, utxos) {
        if (err && err.code === -5) {
            return res.jsonp([]);
        } else if (err) {
            return self.common.handleErrors(err, res);
        }

        res.jsonp(utxos.map(self.transformUtxo.bind(self)));
    });
};

AddressController.prototype.transformUtxo = function (utxoArg) {
    var utxo = {
        address: utxoArg.address,
        txid: utxoArg.txid,
        vout: utxoArg.outputIndex,
        scriptPubKey: utxoArg.script,
        amount: utxoArg.satoshis / 1e8,
        satoshis: utxoArg.satoshis
    };
    if (utxoArg.height && utxoArg.height > 0) {
        utxo.height = utxoArg.height;
        utxo.confirmations = this.node.services.bitcoind.height - utxoArg.height + 1;
    } else {
        utxo.confirmations = 0;
    }
    if (utxoArg.timestamp) {
        utxo.ts = utxoArg.timestamp;
    }
    return utxo;
};

AddressController.prototype._getTransformOptions = function (req) {
    return {
        noAsm: !!parseInt(req.query.noAsm),
        noScriptSig: !!parseInt(req.query.noScriptSig),
        noSpent: !!parseInt(req.query.noSpent)
    };
};

AddressController.prototype.multitxs = function (req, res) {
    var self = this;
    var options = {
        from: parseInt(req.query.from) || parseInt(req.body.from) || 0
    };
    options.to = parseInt(req.query.to) || parseInt(req.body.to) || parseInt(options.from) + 10;
    self.node.getAddressHistory(req.addrs, options, function (err, result) {
        if (err) {
            return self.common.handleErrors(err, res);
        }
        var transformOptions = self._getTransformOptions(req);
        self.transformAddressHistoryForMultiTxs(result.items, transformOptions, function (err, items) {
            if (err) {
                return self.common.handleErrors(err, res);
            }
            res.jsonp({
                totalItems: result.totalCount,
                from: options.from,
                to: Math.min(options.to, result.totalCount),
                items: items
            });
        });
    });

};

AddressController.prototype.transformAddressHistoryForMultiTxs = function (txinfos, options, callback) {
    var self = this;
    var items = txinfos.map(function (txinfo) {
        return txinfo.tx;
    }).filter(function (value, index, self) {
        return self.indexOf(value) === index;
    });
    async.map(
        items,
        function (item, next) {
            self.txController.transformTransaction(item, options, next);
        },
        callback
    );
};

module.exports = AddressController;