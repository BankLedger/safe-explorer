'use strict';

var async = require('async');
var bitcore = require('bitcore-lib-safe');
var _ = bitcore.deps._;
var pools = require('../pools.json');
var BN = bitcore.crypto.BN;
var LRU = require('lru-cache');
var Common = require('./common');

var bs58=bitcore.encoding.Base58Check;

function BlockController(options) {
    var self = this;
    this.node = options.node;

    this.blockSummaryCache = LRU(options.blockSummaryCacheSize || BlockController.DEFAULT_BLOCKSUMMARY_CACHE_SIZE);
    this.blockCacheConfirmations = 6*5;
    //
    this.blockCache = LRU(options.blockCacheSize || BlockController.DEFAULT_BLOCK_CACHE_SIZE);

    this.poolStrings = {};
    pools.forEach(function (pool) {
        pool.searchStrings.forEach(function (s) {
            self.poolStrings[s] = {
                poolName: pool.poolName,
                url: pool.url
            };
        });
    });

    this.common = new Common({log: this.node.log});
}

var BLOCK_LIMIT = 200;

BlockController.DEFAULT_BLOCKSUMMARY_CACHE_SIZE = 1000000;
BlockController.DEFAULT_BLOCK_CACHE_SIZE = 1000;

function isHexadecimal(hash) {
    if (!_.isString(hash)) {
        return false;
    }
    return /^[0-9a-fA-F]+$/.test(hash);
}

BlockController.prototype.totalSupply = function( req , res ){
    res.jsonp( 29600000 );
}

BlockController.prototype.checkBlockHash = function (req, res, next) {
    var self = this;
    var hash = req.params.blockHash;
    if (hash.length < 64 || !isHexadecimal(hash)) {
        return self.common.handleErrors(null, res);
    }
    next();
};

/**
 * Find block by hash ...
 */
BlockController.prototype.block = function (req, res, next) {
    var self = this;
    var hash = req.params.blockHash;
    var blockCached = self.blockCache.get(hash);
    if (blockCached) {
        blockCached.confirmations = self.node.services.bitcoind.height - blockCached.height + 1;
        req.block = blockCached;
        next();
    } else {
        self.node.getBlock(hash, function (err, block) {
            if ((err && err.code === -5) || (err && err.code === -8)) {
                return self.common.handleErrors(null, res);
            } else if (err) {
                return self.common.handleErrors(err, res);
            }
            self.node.services.bitcoind.getBlockHeader(hash, function (err, info) {
                if (err) {
                    return self.common.handleErrors(err, res);
                }
		//console.log(info)
                var blockResult = self.transformBlock(block, info);
                self.node.getRawTransactionJson(blockResult.tx[0], function (err, tx) {
                    if (err) {
                        return self.common.handleErrors(err, res);
                    }
                    blockResult.miner = tx.vout[0].scriptPubKey.addresses[0];

                    if (blockResult.confirmations >= self.blockCacheConfirmations
                        && ! self.blockCache.get( hash ) ) {
                        self.blockCache.set(hash, blockResult);
                    }
                    tx.vout.forEach(function (out) {
                        blockResult.reward = parseFloat((blockResult.reward + out.value).toFixed(8));
                    });
                    req.block = blockResult;
                    next();
                });
            });
        });
    }
};

/**
 * Find rawblock by hash and height...
 */
BlockController.prototype.rawBlock = function (req, res, next) {
    var self = this;
    var blockHash = req.params.blockHash;

    self.node.getRawBlock(blockHash, function (err, blockBuffer) {
        if ((err && err.code === -5) || (err && err.code === -8)) {
            return self.common.handleErrors(err, res);
        } else if (err) {
            return self.common.handleErrors(err, res);
        }
        req.rawBlock = {
            rawblock: blockBuffer.toString('hex')
        };
        next();
    });
};

BlockController.prototype._normalizePrevHash = function (hash) {
    // TODO fix bitcore to give back null instead of null hash
    if (hash !== '0000000000000000000000000000000000000000000000000000000000000000') {
        return hash;
    } else {
        return null;
    }
};

BlockController.prototype.transformBlock = function (blockObj, info) {
    // var blockObj = block.toObject();
    // var transactionIds = blockObj.transactions.map(function (tx) {
    //     return tx.hash;
    // });

    return {
        hash: blockObj.hash,
        size: blockObj.size,
        height: info.height,
        version: blockObj.version,
        merkleroot: blockObj.merkleroot,
        tx: blockObj.tx,
        time: blockObj.time,
        nonce: blockObj.nonce,
        bits: blockObj.bits,
        difficulty: parseFloat(info.difficulty),
        chainwork: info.chainWork,
        confirmations: info.confirmations,
        previousblockhash: this._normalizePrevHash(blockObj.previousblockhash),
        nextblockhash: info.nextHash,
        reward: null,
        isMainChain: (info.confirmations !== -1)
        // poolInfo: this.getPoolInfo(block)
    };
};

/**
 * Show block
 */
BlockController.prototype.show = function (req, res) {
    if (req.block) {
        res.jsonp(req.block);
    }
};

BlockController.prototype.showRaw = function (req, res) {
    if (req.rawBlock) {
        res.jsonp(req.rawBlock);
    }
};

BlockController.prototype.blockIndex = function (req, res) {
    var self = this;
    var height = req.params.height;
    this.node.services.bitcoind.getBlockHeader(height, function (err, info) {
        if (err) {
            return self.common.handleErrors(err, res);
        }
        res.jsonp({
            blockHash: info.hash
        });
    });
};

BlockController.prototype._getBlockSummary = function (hash, moreTimestamp, next) {
    var self = this;

    function finish(result) {
        if (moreTimestamp > result.time) {
            moreTimestamp = result.time;
        }
        return next(null, result);
    }

    var summaryCache = self.blockSummaryCache.get(hash);

    if (summaryCache) {
        finish(summaryCache);
    } else {
        self.node.services.bitcoind.getRawBlock(hash, function (err, blockBuffer) {
            if (err) {
                return next(err);
            }
            // console.log("---------------------------");
            // console.log(hash);
            var br = new bitcore.encoding.BufferReader(blockBuffer);
            // console.log( blockBuffer );

            // take a shortcut to get number of transactions and the blocksize.
            // Also reads the coinbase transaction and only that.
            // Old code parsed all transactions in every block _and_ then encoded
            // them all back together to get the binary size of the block.
            // FIXME: This code might still read the whole block. Fixing that
            // would require changes in bitcore-node.
            var header = bitcore.BlockHeader.fromBufferReader(br);
            var info = {};
            var txlength = br.readVarintNum();

            // console.log(txlength)
            // console.log(br.buf.toString("hex"))
            info.transactions = [bitcore.Transaction().fromBufferReader(br)];
            self.node.services.bitcoind.getBlockHeader(hash, function (err, blockHeader) {
                if (err) {
                    return next(err);
                }
                var height = blockHeader.height;
                var summary = {
                    height: height,
                    size: blockBuffer.length,
                    hash: hash,
                    time: header.time,
                    txlength: txlength,
                    poolInfo: self.getPoolInfo(info)
                };
		//76a91400dfa9d0884b58e9a6220eac59f5afb3cf61bb9488ac
		//
		//
                /**************************************************************************************************/
                if ( summary.height >= 1092826 ){
		var sh=info.transactions[0].outputs[0].script
		var address=sh.toAddress().toString()
                                summary.poolInfo.poolName = address;
				summary.poolInfo.url = "/address/" +  address;
	        }   
                /**************************************************************************************************/

                var confirmations = self.node.services.bitcoind.height - height + 1;
                if (confirmations >= self.blockCacheConfirmations) {
                    self.blockSummaryCache.set(hash, summary);
                }
                finish(summary);
            });
        });
    }
};
BlockController.prototype.TomorrowIsTodayAfter8Hour = function () {
    var now = new Date();
    var _8Hour = new Date(now.getTime() + 28800000);
    if (now.getUTCDate() < _8Hour.getUTCDate()) {
        return _8Hour;
    } else {
        return now;
    }
};
// List blocks by date
BlockController.prototype.list = function (req, res) {
    var self = this;
    var dateStr;
    var todayStr = this.formatTimestamp(this.TomorrowIsTodayAfter8Hour());
    var isToday;

    if (req.query.blockDate) {
        dateStr = req.query.blockDate;
        var datePattern = /\d{4}-\d{2}-\d{2}/;
        if (!datePattern.test(dateStr)) {
            return self.common.handleErrors(new Error('Please use yyyy-mm-dd format'), res);
        }
        isToday = dateStr === todayStr;
    } else {
        dateStr = todayStr;
        isToday = true;
    }

    var lte = parseInt(parseInt(req.query.startTimestamp)) || Math.round((new Date(dateStr).getTime()) / 1000 + 86400 - 8 * 60 * 60 - 1);//greater than this one
    var gte = Math.round((new Date(dateStr)).getTime() / 1000 - 8 * 60 * 60);
    var prev = this.formatTimestamp(new Date((Math.round((new Date(dateStr)).getTime() / 1000) - 86400 ) * 1000));
    var next = isToday ? null : this.formatTimestamp(new Date((Math.round((new Date(dateStr)).getTime() / 1000) + 86400 ) * 1000 + 1));

    var limit = parseInt(req.query.limit || BLOCK_LIMIT);
    var more = false;
    var moreTimestamp = lte;

    self.node.services.bitcoind.getBlockHashesByTimestamp(lte, gte, function (err, hashes) {
        if (err) {
            return self.common.handleErrors(err, res);
        }
        hashes.reverse();
        if (hashes.length > limit) {
            more = true;
            hashes = hashes.slice(0, limit);
        }
        async.mapSeries(
            hashes,
            function (hash, next) {
                self._getBlockSummary(hash, moreTimestamp, next);
            },
            function (err, blocks) {

                if (err) {
                    return self.common.handleErrors(err, res);
                }

                blocks.sort(function (a, b) {
                    return b.height - a.height;
                });
                var data = {
                    blocks: blocks,
                    length: blocks.length,
                    pagination: {
                        next: next,
                        prev: prev,
                        currentTs: lte - 1,
                        current: dateStr,
                        isToday: isToday,
                        more: more
                    }
                };
                if (more) {
                    data.pagination.moreTs = blocks[blocks.length - 1].time;
                }
                res.jsonp(data);
            }
        );
    });
};

BlockController.prototype.getPoolInfo = function (block) {
    var coinbaseBuffer = block.transactions[0].inputs[0]._scriptBuffer;
    for (var k in this.poolStrings) {
        if (coinbaseBuffer.toString('utf-8').match(k)) {
            return this.poolStrings[k];
        }
    }
    return {};
};

//helper to convert timestamps to yyyy-mm-dd format
BlockController.prototype.formatTimestamp = function (date) {
    var yyyy = date.getFullYear().toString();
    var mm = (date.getMonth() + 1).toString(); // getMonth() is zero-based
    var dd = date.getDate().toString();

    return yyyy + '-' + (mm[1] ? mm : '0' + mm[0]) + '-' + (dd[1] ? dd : '0' + dd[0]); //padding
};

/**
 * Previous blockHeader is used to determine block reward
 */
BlockController.prototype.getPreviousBlock = function (prevHash, res, cb) {
    var self = this;
    self.node.getBlock(prevHash, function (err, block) {
        if ((err && err.code === -5) || (err && err.code === -8)) {
            return self.common.handleErrors(null, res);
        } else if (err) {
            return self.common.handleErrors(err, res);
        }

        self.node.services.bitcoind.getBlockHeader(prevHash, function (err, info) {
            if (err) {
                return self.common.handleErrors(err, res);
            }
            cb(null, info); // return blockHeader
        });
    });
};

BlockController.prototype.getBlockReward = function (prevHash, res, cb) {
    var self = this;
    var nSubsidyHalvingInterval = 210240;
    var nBudgetPaymentsStartBlock = 100000;
    var nSubsidyBase;

    // block reward is based on the previous block diff / height
    self.getPreviousBlock(prevHash, res, function (err, info) {
        if (err) cb(err, null);

        var dDiff = info.difficulty;
        var nPrevHeight = info.height;

        if (nPrevHeight < 5465) {
            // Early ages...
            // 1111/((x+1)^2)
            nSubsidyBase = (1111.0 / (Math.pow((dDiff + 1.0), 2.0)));
            if (nSubsidyBase > 500) nSubsidyBase = 500;
            else if (nSubsidyBase < 1) nSubsidyBase = 1;
        } else if (nPrevHeight < 17000 || (dDiff <= 75 && nPrevHeight < 24000)) {
            // CPU mining era
            // 11111/(((x+51)/6)^2)
            nSubsidyBase = (11111.0 / (Math.pow((dDiff + 51.0) / 6.0, 2.0)));
            if (nSubsidyBase > 500) nSubsidyBase = 500;
            else if (nSubsidyBase < 25) nSubsidyBase = 25;
        } else {
            // GPU/ASIC mining era
            // 2222222/(((x+2600)/9)^2)
            nSubsidyBase = (2222222.0 / (Math.pow((dDiff + 2600.0) / 9.0, 2.0)));
            if (nSubsidyBase > 25) nSubsidyBase = 25;
            else if (nSubsidyBase < 5) nSubsidyBase = 5;
        }

        var nSubsidy = nSubsidyBase;

        // yearly decline of production by ~7.1% per year, projected ~18M coins max by year 2050+.
        for (var i = nSubsidyHalvingInterval; i <= nPrevHeight; i += nSubsidyHalvingInterval) {
            nSubsidy -= nSubsidy / 14;
        }

        // Hard fork to reduce the block reward by 10 extra percent (allowing budget/superblocks)
        var nSuperblockPart = (nPrevHeight > nBudgetPaymentsStartBlock) ? nSubsidy / 10 : 0;
        var reward = nSubsidy - nSuperblockPart;
        cb(null, parseFloat(reward.toString(10)).toFixed(8));
    });
};

module.exports = BlockController;
