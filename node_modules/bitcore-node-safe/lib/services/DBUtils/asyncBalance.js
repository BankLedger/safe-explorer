'use strict';

const async = require( 'async' );
var mysql = require("./MysqlUtils");
var SafeApi = require("./safedsaferpc");

const ADDRESS_CONFIG = {
    BLACK_HOLE_ADDRESS:     'XagqqFetxiDb9wbartKDrXgnqLah6SqX2S' , 
    APP_DESTORY_ADDRESS:    'XagqqFetxiDb9wbartKDrXgnqLah9fKoTx' ,
    TEAM_LOCKED_ADDRESS:    'XmVvAye4ph9s3M5AjrWDRFAzTKrkpwcHHR'
}

function AsyncBalanceUpdate( DB , SafeRPCConfig ){
    // this.DB = new mysql( MySQLConfig );
    this.DB = DB;
    this.RPC = new SafeApi( SafeRPCConfig );
    this.process = {
        dbHeight:0,
        latestHeight:0
    }
}
AsyncBalanceUpdate.prototype.start = function() {
    const self = this;
    async.waterfall( [
        ( callback ) => { 
            self.initExecuteRange( function( error ){
                callback( error );
            } )
        },
        ( callback ) => {
            self.executeAsync( function( error ){
                callback( error )
            } );
        },
        ( callback ) => {
            if ( self.process.dbHeight > 0 && self.process.dbHeight % 10 == 0 ){
                self.updateMasternodeUnlockTotalAmount( self.process.dbHeight , function(err){
                    callback(err)
                } );
            }else{
                callback( null );
            }
        }
    ] , function(err){
        if (err) {
            self.log("===================================")
            self.log("当前执行周期出现错误,5S后重新执行.")
            self.log(JSON.stringify(err));
            self.log("===================================")
        }
        setTimeout( ()=> self.start() , 5000 );
    } )
}

/**
 * 初始化执行任务高度区间
 */
AsyncBalanceUpdate.prototype.initExecuteRange = function( callback ){
    const self = this;
    async.series({
        dbHeight:function( callback ){
            if ( self.process.dbHeight > 0 ){
                callback( null , self.process.dbHeight );
                return;
            }
            self.DB.getBlockAmountStatisticHeight( ( err , result )=>{
                callback( null , result[0].height);
            });
        },
        latestHeight:function( callback ){
            self.RPC.safedCall( 'getinfo' , function( err, response ){
                if ( err ){
                    callback(err);
                    return;
                }
                callback( null , response.result.blocks );
            } )
        }
    },function(err,results){
        if (err){
            callback(err);
        }
        // 只对完成6个确认的区块数据中的地址进行余额更新
        let latestHeight = results.latestHeight - 6;
        self.process = {
            dbHeight:results.dbHeight,
            latestHeight:latestHeight
        }
        self.log('确定SAFE余额更新执行范围 : [' + results.dbHeight + " ~ " + latestHeight + ']');
        if ( callback ){
            callback();
        }
    })
};

AsyncBalanceUpdate.prototype.executeAsync = function( callback ){
    const self = this;
    async.whilst(
        function(){                 // Condition
            return self.process.dbHeight + 1 <= self.process.latestHeight;
        },
        function(callback){         // Execution
            let dbHeight = self.process.dbHeight + 1;
            self.log( 'sync height:' + dbHeight );
            self.handleBlock( dbHeight , function( err ){
                if (err) return callback(err);
                // 当完成一个区块内的地址余额更新时 , 更新表，及 self.process { dbHeight }
                self.handleHeightStatisticUpdate( dbHeight , function(err , result){
                    if (err) return callback(err);
                    self.process.dbHeight ++ ;
                    callback(); 
                } );
            } );
        },
        function(err){                 // ALL FINISH
            if (err) return callback(err) ;
            self.log( '已完成当前执行区间' );
            if ( callback ){
                callback();
            }
        }
    )
}

AsyncBalanceUpdate.prototype.handleBlock = function( height , callback ){
    const self = this;
    async.waterfall( [
        function( callback ){   // getblockhash
            self.RPC.safedCall( 'getblockhash' , height , function( err , response ){
                self.log('getblockhash for height:'+height);
                if ( err ) return callback( err , null )
                callback( null , response.result  /** blockhash */  );
            } )
        } , 
        function( blockhash , callback ){   // handleblockhash
            self.RPC.safedCall( 'getblock' , blockhash , function( err, response ){
                self.log('getblockinfo for height:'+height);
                if ( err ) return callback( err , null )
                callback( null , response.result.tx /** {}.tx数组 */ )
            }  )
        } , 
        function( txArr , callback ){       // 解析每一个出现在 vin/vout 中的地址,将其全部搞出来
            self.getAddressInTxArr( txArr , function( err, addrArr ){
                callback( err , addrArr )
            } );
        } , 
        function ( addrArr , callback ){    // 如果存在当前高度解锁了的地址，则需要将这些地址查询出来，再下一步的函数中进行余额更新
            self.DB.getUnlockAddress( height , function( err , result ){
                if ( err ) return callback( err , result );
                result.forEach( element => addrArr.push( element.address ) );
                callback( null , addrArr );  
            } );
        },
        function ( addrArr , callback ){    // 对于每个地址进行获取余额，并更新到数据库
            addrArr = self.set( addrArr );  // 去掉可能重复的地址
            self.log("parse Addr in block:" + addrArr)
            self.handleAddressBalanceUpdate( addrArr , height , function( err ){
                callback( err );
            } )
        }
    ] 
        , function( err, addrArr ){   // DONE
            if (callback) callback( err,addrArr );
        }
    )
}

/**
 * 对地址数组中的每一个地址进行访问 RPC 获取 Balance , 然后更新到数据库中
 * @param {*} addrArr 
 * @param {*} height 
 * @param {*} callback 
 */
AsyncBalanceUpdate.prototype.handleAddressBalanceUpdate = function( addrArr , height , callback ){
    const self = this;
    async.eachLimit( addrArr , 2 , function( address , callback ){
        async.waterfall( [
            function( callback ){ // 查询数据库是否存在数据
                self.DB.getAddressBalance( address , function( err , result ){
                    let balanceaddress = undefined;
                    if ( result.length > 0 ){
                        balanceaddress = result[0];
                    }
                    callback( err , balanceaddress , address );
                } )
            },
            function( balanceaddress , address , callback ){ // 如果存在数据,则比较当前的同步高度是否大于数据的最后更新高度,如果大于,才访问RPC进行数据更新
                let latestUpdateHeight = 0;
                if ( balanceaddress ){
                    latestUpdateHeight = balanceaddress.latestUpdateHeight;
                }
                if ( height <= latestUpdateHeight ) {
                    balanceaddress.latestTxHeight = height;
                    balanceaddress.rpced = false;
                    callback( null , balanceaddress );
                } else {
                    self.RPC.safedCall( 'getAddressBalance' , JSON.stringify( { addresses:[ address ] } ) , function( err , response ){
                        self.log( 'RPC - getAddressBalance for ' + address + ' <=' + JSON.stringify(response) )
                        if ( err ) return callback( err , null );
                        if ( response.result ){
                            balanceaddress = {
                                address: address,
                                balance: response.result.balance,
                                locked: response.result.lockamount,
                                latestTxHeight: height,
                                latestUpdateHeight: self.process.latestHeight,
                                rpced:true
                            }
                        }
                        callback( null , balanceaddress );
                    });
                }
            },
            function( balanceaddress , callback ){ // 将数据进行DB更新
                if ( balanceaddress ){
                    self.DB.updateAddressBalance( balanceaddress , function( err , result ){
                        self.log( 'update balanceaddress:' + JSON.stringify( balanceaddress ) );
                        callback( err , result );
                    } )
                }else{
                    callback( err , result );
                }
            }
        ] , function( err ){
            callback( err );
        } );
    } , function(err){
        if ( callback ){
            callback(err);
        }
    });
}


/**
 * 获取交易数组内关联的交易地址
 * @param {*} txArr 
 * @param {*} callback 
 * 
 */
AsyncBalanceUpdate.prototype.getAddressInTxArr = function( txArr , callback ){
    const self = this;
    let addrArr = [];
    let vin_UTXO_arr = [];
    async.eachLimit( txArr , 5 , function( txhash , callback ){
        self.RPC.safedCall( 'getrawtransaction' , txhash , 1 , function( err , response ){
            if ( err ) return callback( err );
            let vin = response.result.vin;
            let vout = response.result.vout;
            vout.forEach( _vout => {
                if ( _vout.scriptPubKey.addresses ){
                    addrArr.push( _vout.scriptPubKey.addresses[0] );
                }
            } );
            vin.forEach( _vin => {
                if ( _vin.txid ){
                    vin_UTXO_arr.push( {
                        txid:_vin.txid,
                        vout:_vin.vout
                    } );
                }
            });
            callback();
        } )
    } , function(err){
        if (err){
            return callback(err);
        }
        if ( vin_UTXO_arr.length == 0 ){
            if ( callback ){
                callback( null, addrArr );
            }
        }
        if ( vin_UTXO_arr.length > 0 ){
             async.eachLimit( vin_UTXO_arr , 5 , function( utxo , callback ){
                let txid = utxo.txid;
                let vout = utxo.vout;
                self.RPC.safedCall( 'getrawtransaction',txid,1,function( err , response ){
                    if ( err ) return callback( err );
                    if ( response.result.vout[ vout ].scriptPubKey.addresses ){
                        addrArr.push(
                            response.result.vout[ vout ].scriptPubKey.addresses[0]
                        )
                    }
                    callback();
                } );
            } , function( err ){
                if (callback) {
                    callback( err, addrArr );
                }
            } );
        } 
    } );
}

/**
 * 更新指定高度下的金额统计
 * @param {*} height 
 */
AsyncBalanceUpdate.prototype.handleHeightStatisticUpdate = function( height , callback ){
    var self = this;
    async.series({
        totalAddressAmount:function( callback ){
            self.DB.getTotalAddressBalance( function( err , result ){
                callback( err , result[0].totalAmount );
            } )
        } , 
        totalLockedAmount:function( callback ){
            self.DB.getTotalLockedAmountForAssetName( { unlockedHeight:height , assetName:'safe' } , function( err , result ){
                callback( err , result[0].totalLocked * Math.pow(10,9) / 10 );
            } );
        } , 
        blackHoleAmount:function( callback ){   // 黑洞地址
            self.DB.getAddressBalance( ADDRESS_CONFIG.BLACK_HOLE_ADDRESS , function( err , result ){
                callback( err,result[0].balance )
            } )
        } , 
        appDestoryAmount:function( callback ){  // 安资发行销毁地址
            self.DB.getAddressBalance( ADDRESS_CONFIG.APP_DESTORY_ADDRESS , function( err , result ){
                callback( err,result[0].balance )
            } )
        } , 
        teamLockedAmount:function( callback ){ // 团队锁定数量
            self.DB.getAddressBalance( ADDRESS_CONFIG.TEAM_LOCKED_ADDRESS , function( err , result ){
                callback( err,result[0].locked )
            } )
        },
        masternodeCount:function( callback ){   
            self.RPC.safedCall( 'masternode' , 'count' , function( err , result ){
                callback( err , result.result )
            } )
        }
    }, 
    function( errs, results ){
        results.totalDestoryAmount = results.appDestoryAmount;
        results.totalAddressAmount = results.totalAddressAmount - results.blackHoleAmount; 
        results.totalFlowAmount = results.totalAddressAmount - results.totalLockedAmount - results.totalDestoryAmount;
        results.height = height;
        console.log( results );
        // UPDATE DB
        self.DB.updateBlockAmountStatisticRecord2( results , function(){
            if (callback) return callback();
        } );
    });
}

AsyncBalanceUpdate.prototype.log = function( msg ){
    const self = this;
    console.log( "#AsyncBalanceUpdate# ["+self.process.dbHeight+" / "+ self.process.latestHeight +"] [INFO] : " + msg );
}

/**
 * 
 */
AsyncBalanceUpdate.prototype.updateMasternodeUnlockTotalAmount = function( height , callback ){
    const self = this;
    async.series({
        unlockTxList:function( callback ){
            self.DB.getUnlockMasternodeTxList( height , ( err , result )=>{
                if (err) return callback(err);
                var unlockTxList = [];
                result.forEach( data => {
                    var idArr = data.id.split('_');
                    var txIndex = idArr[1]+"-"+idArr[2];
                    unlockTxList.push( txIndex );
                } )
                self.log('查询当前高度已解锁的 1000 Tx-Index / Length = ' + unlockTxList.length)
                callback( null , unlockTxList);
            });
        },
        masternodeTxList:function( callback ){
            self.RPC.safedCall( 'masternode' , 'list' , function( err, response ){
                if (err) return callback(err)
                var masternodeTxList = [];
                for( var txIndex in response.result ){
                    masternodeTxList.push(txIndex)
                }
                self.log('查询当前网络主节抵押交易 masternode-list / Length = ' + masternodeTxList.length)
                callback( null , masternodeTxList );
            } )
        }
    },function(err,results){
        if (err) return callback(err);
        // 只对完成6个确认的区块数据中的地址进行余额更新
        var unlockTxList = results.unlockTxList;
        var masternodeTxList = results.masternodeTxList;
        var masternodeUnlockTxList = [];
        masternodeTxList.forEach( masternodeTxIndex => {
            if ( unlockTxList.indexOf(masternodeTxIndex) !== -1 ){
                masternodeUnlockTxList.push(masternodeTxIndex);
            }
        } )
        self.log('当前网络所有主节点抵押交易中,已存在解锁 : ' + masternodeUnlockTxList.length);
        self.DB.updateMasternodeUnlockTxCount( masternodeUnlockTxList.length , function(){
            if ( callback ){
                callback();
            }
        } )
    })
}

/**
 * 对数组元素进行去重复
 * @param {} addrArr 
 */
AsyncBalanceUpdate.prototype.set = function( addrArr ){
    let newsArr = [];
    for (let i = 0; i < addrArr.length; i++) {
     if(newsArr.indexOf(addrArr[i]) === -1){
      newsArr.push(addrArr[i]);
     }
    }
    return newsArr;
}

// const config = {
//     MySQLConfig:{
//         "host": "rm-wz90u612mp7r8m297wo.mysql.rds.aliyuncs.com",
//         "port": 3306,
//         "user": "root",
//         "password": "Zy123456!",
//         "database": "lockedAddresses"
//     } , 
//     SafeRPCConfig:{
//         host :'125.74.93.39' ,
//         port : 6554 ,
//         user :'rpcuser' , 
//         pass :'rpcpass',
//     }
// }
// const work = new AsyncBalanceUpdate( new mysql(config.MySQLConfig)  , config.SafeRPCConfig );
// work.handleHeightStatisticUpdate( 3343975 , function(){
//     console.log( 'DONE' );
// } );
// work.DB.getBlockAmountStatistic( ( err ,result )=>{
//     console.log( result );
//     console.log( '111' );
// } )
// work.handleBlock( 807028, function(){
//     console.log( '完成区块内关联地址余额更新..' );
// });
// const addrArr = ['XvHDEHE48o8B1t8dJYE7WM9atMF9MRGUKv','XdcPkDLjKbyjejicU7qDztjbwDYRMUGLCR' ]
// work.handleAddressBalanceUpdate( addrArr , 100 , function( err , result ){
//     console.log( 'finish !!!' );
// } );
// console.log( 178378559364 / Math.pow( 10 , 8 ) );
// let txid = 'ce9ef55f51b2bd5a20c7fcf3fd515762ba9e0c47ac3b5f1601d8328516bf402f';
// work.RPC.safedCall( 'getrawtransaction',txid,1,function( err , response ){
//     console.log( err );
//     console.log(response);
// } );
// work.start();
// console.log( 29400000 * Math.pow(10 , 8) );
// work.updateMasternodeUnlockTotalAmount( 3755987 );
// console.log( 3755101 % 100 === 0 );

module.exports = AsyncBalanceUpdate;




