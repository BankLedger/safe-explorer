'use strict';

var http = require('http');

function SafeApi(opts) {
    opts = opts || {};
    this.host = opts.host || '127.0.0.1';
    this.port = opts.port || 11109;
    this.user = opts.user || 'rpcuser';
    this.pass = opts.pass || 'rpcpass';
    this.protocol = http;

    this.log = SafeApi.loggers['normal'];

}

var cl = console.log.bind(console);

var noop = function () {
};

SafeApi.loggers = {
    none: {info: noop, warn: noop, err: noop, debug: noop},
    normal: {info: cl, warn: cl, err: cl, debug: noop},
    debug: {info: cl, warn: cl, err: cl, debug: cl}
};

SafeApi.config = {
    logger: 'normal' // none, normal, debug
};

function rpc(request, callback) {

    var self = this;
    request = JSON.stringify(request);
    var auth = new Buffer(self.user + ':' + self.pass).toString('base64');
    var options = {
        host: self.host,
        path: '/',
        method: 'POST',
        port: self.port,
        rejectUnauthorized: false,
        agent: undefined
    };

    if (self.httpOptions) {
        for (var k in self.httpOptions) {
            options[k] = self.httpOptions[k];
        }
    }

    var called = false;

    var errorMessage = 'SafeApi JSON-RPC: ';

    var req = this.protocol.request(options, function (res) {

        var buf = '';
        res.on('data', function (data) {
            buf += data;
        });

        res.on('end', function () {
            if (called) {
                return;
            }
            called = true;

            if (res.statusCode === 401) {
                callback(new Error(errorMessage + 'Connection Rejected: 401 Unnauthorized'));
                return;
            }
            if (res.statusCode === 403) {
                callback(new Error(errorMessage + 'Connection Rejected: 403 Forbidden'));
                return;
            }
            if (res.statusCode === 500 && buf.toString('utf8') === 'Work queue depth exceeded') {
                var exceededError = new Error('Bitcoin JSON-RPC: ' + buf.toString('utf8'));
                exceededError.code = 429; // Too many requests
                callback(exceededError);
                return;
            }
            var parsedBuf;
            try {
                parsedBuf = JSON.parse(buf);

            } catch (e) {
                self.log.err(e.stack);
                self.log.err(buf);
                self.log.err('HTTP Status code:' + res.statusCode);
                var err = new Error(errorMessage + 'Error Parsing JSON: ' + e.message);
                callback(err);
                return;
            }
            callback(parsedBuf.error, parsedBuf);

        });
    });
    req.on('socket', function (socket) {
        // 性能好的机器可以放 60s , 性能差的又需要查询余额的话，这里得调大一点.
        var timeout = 600000;
        socket.setTimeout(timeout);
        socket.on('timeout', function () {
            console.log("request time out after:" + timeout);
            req.abort();
        });
    });
    req.on('error', function (e) {
        var err = new Error(errorMessage + 'Request Error: ' + e.message);
        if (!called) {
            called = true;
            callback(err);
        }
    });

    req.setHeader('Content-Length', request.length);
    req.setHeader('Content-Type', 'application/json');
    req.setHeader('Authorization', 'Basic ' + auth);
    req.write(request);
    req.end();
}

SafeApi.callspec = {
    abandonTransaction: 'str',
    addMultiSigAddress: '',
    addNode: '',
    backupWallet: '',
    createMultiSig: '',
    createRawTransaction: '',
    decodeRawTransaction: '',
    dumpPrivKey: '',
    encryptWallet: '',
    estimateFee: 'int',
    estimatePriority: 'int',
    generate: 'int',
    getAccount: '',
    getAccountAddress: 'str',
    getAddedNodeInfo: '',
    getAddressMempool: 'obj',
    getAddressUtxos: 'obj',
    getAddressBalance: 'obj',
    getAddressDeltas: 'obj',
    getAddressTxids: 'obj',
    getAddressesByAccount: '',
    getBalance: 'str int',
    getBestBlockHash: '',
    getBlockDeltas: 'str',
    getBlock: 'str bool',
    getBlockchainInfo: '',
    getBlockCount: '',
    getBlockHashes: 'int int obj',
    getBlockHash: 'int',
    getBlockHeader: 'str',
    getBlockNumber: '',
    getBlockTemplate: '',
    getConnectionCount: '',
    getChainTips: '',
    getDifficulty: '',
    getGenerate: '',
    getHashesPerSec: '',
    getInfo: '',
    getMemoryPool: '',
    getMemPoolInfo: '',
    getMiningInfo: '',
    getNewAddress: '',
    getPeerInfo: '',
    getRawMemPool: '',
    getRawTransaction: 'str int',
    getReceivedByAccount: 'str int',
    getReceivedByAddress: 'str int',
    getSpentInfo: 'obj',
    getTransaction: '',
    getTxOut: 'str int bool',
    getTxOutSetInfo: '',
    getWork: '',
    gobject: 'str str',
    help: '',
    importAddress: 'str str bool',
    importPrivKey: 'str str bool',
    invalidateBlock: 'str',
    keyPoolRefill: '',
    listAccounts: 'int',
    listAddressGroupings: '',
    listReceivedByAccount: 'int bool',
    listReceivedByAddress: 'int bool',
    listSinceBlock: 'str int',
    listTransactions: 'str int int',
    listUnspent: 'int int',
    listLockUnspent: 'bool',
    lockUnspent: '',
    move: 'str str float int str',
    prioritiseTransaction: 'str float int',
    sendFrom: 'str str float int str str',
    sendMany: 'str obj int str',  //FIXME : not sure this is will work
    sendRawTransaction: 'str bool bool',
    sendToAddress: 'str float str str',
    setAccount: '',
    setGenerate: 'bool int',
    setTxFee: 'float',
    signMessage: '',
    signRawTransaction: '',
    stop: '',
    submitBlock: '',
    validateAddress: '',
    verifyMessage: '',
    walletLock: '',
    walletPassPhrase: 'string int',
    walletPassphraseChange: '',
    masternodelist: 'str str',
    masternode: 'str',
    getassetlist: '',   //资产列表
    getassetinfo: 'str',//资产详情
    getaddrassetbalance: 'str str', //根据地址和资产ID获取地址余额
    getaddrassettxids: 'str str int',   //根据地址和资产ID获取交易列表
    getassetidtxids: "str int",     //根据资产id和类型返回资产交易
    sendmanywithlock:"obj",
    sendwithlock:"str int int"
};

var slice = function (arr, start, end) {
    return Array.prototype.slice.call(arr, start, end);
};

function generateRPCMethods(constructor, apiCalls, rpc) {

    function createRPCMethod(methodName, argMap) {
        return function () {

            var limit = arguments.length - 1;

            for (var i = 0; i < limit; i++) {
                if (argMap[i]) {
                    arguments[i] = argMap[i](arguments[i]);
                }
            }

            rpc.call(this, {
                method: methodName,
                params: slice(arguments, 0, arguments.length - 1),
                id: getRandomId()
            }, arguments[arguments.length - 1]);
        };
    };

    var types = {
        str: function (arg) {
            return arg.toString();
        },
        int: function (arg) {
            return parseFloat(arg);
        },
        float: function (arg) {
            return parseFloat(arg);
        },
        bool: function (arg) {
            return (arg === true || arg == '1' || arg == 'true' || arg.toString().toLowerCase() == 'true');
        },
        obj: function (arg) {
            if (typeof arg === 'string') {
                return JSON.parse(arg);
            }
            return arg;
        }
    };

    for (var k in apiCalls) {
        var spec = apiCalls[k].split(' ');
        for (var i = 0; i < spec.length; i++) {
            if (types[spec[i]]) {
                spec[i] = types[spec[i]];
            } else {
                spec[i] = types.str;
            }
        }
        var methodName = k.toLowerCase();
        constructor.prototype[k] = createRPCMethod(methodName, spec);
        constructor.prototype[methodName] = constructor.prototype[k];
    }

}

function getRandomId() {
    return parseInt(Math.random() * 100000);
}

generateRPCMethods(SafeApi, SafeApi.callspec, rpc);

module.exports = SafeApi;
