'use strict';
var SafeApi = require("./safedsaferpc");

var async = require("async");
var SendRequest = require("./sendRequest");

var step = 50;
var startHeight = 900000;
var endHeight = 9999999;
var bTime = new Date().getTime();

function AsyncAddress(RPCConf, DB, sendConf) {
    this.api = new SafeApi(RPCConf, 5);
    this.DB = DB;
    this.request = new SendRequest(sendConf);

    this.startTime = 1535731200;
    this.endTime = 1546272000;
}

AsyncAddress.prototype.error = function (error, msg) {
    var self = this;
    if (error) {
        console.error(error);
        console.error(msg);
        console.log("系统异常，等待执行。");
        setTimeout(function () {
            self.initAsyncHeight();
        }, 5 * 1000);
    }
};

/**
 * 开始同步，并确定开始的的高度
 */
AsyncAddress.prototype.start = function () {
    var self = this;
    self.DB.getAsyncBlockHeight(function (err, block) {
        if (err) {
            return this.error(err, "get async block height err");
        }
        if (block && block.height > 0) {
            startHeight = parseInt(block.height);
        }
        console.log("get db current async height :" + startHeight);
        self.getLastHeight();
    });
};

/**
 * 得到当前最高区块的高度
 */
AsyncAddress.prototype.getLastHeight = function () {
    var self = this;
    self.api.safedCall("getinfo", function (err, info) {
        if (err) {
            return self.error(err, "get info err");
        }
        endHeight = info.result.blocks - 6;
        console.log("get chain last block height : " + endHeight);
        self.initAsyncHeight()
    });
};

/**
 * 循环当前同步的高度和最高区块之间的50个
 */
AsyncAddress.prototype.initAsyncHeight = function () {
    var self = this;
    var theEndHeight = startHeight + step > endHeight ? endHeight : startHeight + step;
    self.eachBlockHeight(startHeight, theEndHeight, function (currentHeight) {
        startHeight = currentHeight;
        self.DB.updateAsyncBlockHeight(currentHeight, function (err) {
            if (err) {
                return self.error(err, "update async block height err : ");
            }
            if (startHeight >= endHeight) {
                self.timer();
            } else {
                self.initAsyncHeight();
            }
        });
    })
};

/**
 * 解析从start开始到end 的区块，获取其中的地址
 * 查询DB是否存在，如果不存在获取地址的金额，并插入数据库中去
 */
AsyncAddress.prototype.eachBlockHeight = function (start, end, doneCb) {
    var self = this;
    var begin = new Date().getTime();
    var beginHeight = start;
    async.whilst(function () {
        return start < end;
    }, function (eachCB) {
        self.getBlockDetailByHeight(start, function () {
            start++;
            eachCB();
        });
    }, function () {
        var currTime = new Date().getTime();
        var processTime = currTime - begin;
        var totalTime = getSpendTimeDesc(currTime - bTime);
        console.log("****************************************************************");
        console.log("[" + beginHeight + "-" + end + "]已经处理完 耗时:" + processTime + "总运行时长:" + totalTime);
        console.log("****************************************************************");
        doneCb(start);
    })
};

/**
 * 将区块高度对应的区块解析出来，获取其中的地址
 * 查询数据库，如果存在，不做处理，如果不存在插入到数据库中去
 */
AsyncAddress.prototype.getBlockDetailByHeight = function (height, cb) {
    var self = this;
    self.api.safedCall("getBlockHash", height, function (err, result) {
        if (err) {
            return self.error(err, "ERROR 根据高度获取区块hash:" + height);
        }
        var blockHash = result.result;
        self.api.safedCall("getBlock", blockHash, true, function (err, rs) {
            if (err) {
                return self.error(err, "ERROR get block hash : " + blockHash);
            }

            self.getTransactionJson(rs.result.tx, function (safeLockedOut) {
                async.each(safeLockedOut, function (item, eachCB) {
                    if (item.lockedValInterest > 0 && item.lockedMonth >= 6 && item.txType == 1) {
                        self.request.send({
                            chainId: item._id,
                            address: item.address,
                            amount: item.lockedVal,
                            txId: item.txId,
                            txTime: item.txTime,
                            lockedHeight: item.lockedHeight,
                            unlockedHeight: item.unlockedHeight,
                            lockedValInterest: item.lockedValInterest,
                            lockedMonth: item.lockedMonth
                        }, function (err, result) {
                            if (err) {
                                console.log("request end err " + err);
                            }
                            if (result.code === 1) {
                                console.error("send request error " + JSON.stringify(result));
                            }
                        })
                    }
                    self.insertAddress(item, function () {
                        eachCB();
                    })
                }, function () {
                    cb();
                })
            });
        });
    });
};

/**
 * 传入参数 block的JSON对象
 * 解析这个JSON对象，获取其中的地址
 * 根据地址查询DB，如果存在，那么不错处理，如果不存在，那么处理这个地址
 */
AsyncAddress.prototype.getTransactionJson = function (txIds, cb) {
    var self = this;
    var safeLockedOut = [];
    async.each(txIds, function (txId, eachCB) {
        self.api.safedCall("getrawtransaction", txId, 1, function (err, tx) {
            if (err) {
                return self.error("get raw transaction err ", err);
            }
            tx = tx.result;
            tx.vout.forEach(function (val) {
                if (val.unlockedHeight > 0 && val.txType < 3) {
                    if (val.scriptPubKey.addresses && val.scriptPubKey.addresses[0]) {

                        var lockedMonth = Math.round((val.unlockedHeight - (tx.locktime || startHeight )) / 17280);
                        safeLockedOut.push({
                            _id: val.scriptPubKey.addresses[0] + "_" + tx.txid + "_" + val.n, // 唯一标识
                            txTime: tx.time,
                            address: val.scriptPubKey.addresses[0],
                            txId: tx.txid,
                            lockedVal: val.value,
                            lockedHeight: tx.height,
                            unlockedHeight: val.unlockedHeight,
                            lockedValInterest: self.calculationOfInterest(val.value, lockedMonth, tx.time), //todo 保留的字段计算锁定的利息
                            lockedMonth: lockedMonth,
                            txType: val.txType,
                            assetId: val.assetId
                        })
                    }
                }
            });
            eachCB();
        })
    }, function () {
        cb(safeLockedOut);
    });
};

AsyncAddress.prototype.calculationOfInterest = function (value, lockedMonth, time) {
    var per = 100;
    // 每个月大概17280个块
    if (time < this.endTime && time >= this.startTime) {
        if (value >= 100) {
            var rate = 4;
            if (lockedMonth >= 6) {
                if (lockedMonth >= 12) {
                    rate = 5;
                    lockedMonth = 12;
                }

                var rateOne = [1537027200, 1];
                var rateTwo = [1537977600, 0.5];
                var rateThree = [1539187200, 0.25];

                if (time >= this.startTime && time < rateOne[0]) {
                    rate += rateOne[1]
                } else if (time > rateOne[0] && time < rateTwo[0]) {
                    rate += rateTwo[1]
                } else if (time > rateTwo[0] && time < rateThree[0]) {
                    rate += rateThree[1]
                }
                rate /= per;
                var lockedValInterest = ((rate * value) ) * (lockedMonth / 12);
                return parseFloat(lockedValInterest.toFixed(4));
            }
        }
    }
    return 0;
};

/**
 * 处理某个某个地址
 * 查询数据库，检查这个地址存不存在，存在不做处理
 * 不存在那么将调用RPC获取地址的余额，之后将数据存放到DB中去
 */
AsyncAddress.prototype.insertAddress = function (out, cb) {
    var self = this;
    if (out.txType == 1) { //添加safe交易
        delete out.txType;
        this.DB.insertToSafe(out, cb);
    } else if (out.txType == 2) {//添加资产交易
        self.DB.getAssetNameByAssetId(out.assetId, function (err, asset) {
            if (err) {
                return self.error("get asset name by asset if ", err);
            }
            if (asset.length > 0) {
                out.assetName = asset[0].assetShortName;
                self.DB.insertToAssets(out, cb);
            } else {
                self.api.safedCall("getassetinfo", out.assetId, function (err, asset) {
                    if (err) {
                        return self.error("get asset info err ", err);
                    }
                    out.assetName = asset.result.assetShortName;
                    self.DB.insertAssetInfo({
                        assetId: out.assetId,
                        name: asset.result.assetName,
                        shortName: asset.result.assetShortName
                    }, function (err) {
                        if (err) {
                            return self.error("insert asset info err ", err);
                        }
                    });
                    self.DB.insertToAssets(out, cb);
                });
            }
        })
    }
};

/**
 * 定时器，当同步完成所有区块是启动
 */
AsyncAddress.prototype.timer = function () {
    var self = this;
    console.log("全部同步结束，等待下一次同步。");
    setTimeout(function () {
        self.getLastHeight();
    }, 60 * 1000)
};

/**
 * 获取总的耗时
 * 多少小时，多少分钟，多少秒
 */
function getSpendTimeDesc(time) {
    var h = parseInt(time / (60 * 60 * 1000));
    var m = parseInt((time - h * 60 * 60 * 1000) / (60 * 1000));
    var s = parseInt((time - h * 60 * 60 * 1000 - m * 60 * 1000) / (1000));
    return h + "小时" + m + "分钟" + s + "秒";
}

module.exports = AsyncAddress;
