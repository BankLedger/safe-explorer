'use strict';

var fs = require('fs');
var path = require('path');
var spawn = require('child_process').spawn;
var util = require('util');
var mkdirp = require('mkdirp');
var bitcore = require('bitcore-lib-safe');
var zmq = require('zmq');
var async = require('async');
var LRU = require('lru-cache');
var BitcoinRPC = require('bitcoind-rpc-safe');
var $ = bitcore.util.preconditions;
var _ = bitcore.deps._;
var Transaction = bitcore.Transaction;
var Proposal = bitcore.GovObject.Proposal;
var mysql = require("./DBUtils/MysqlUtils");
var DB = new mysql(bitcore.DBConfig.mysqlDBConfig);
var SAFE_API_DB = new mysql(bitcore.DBConfig.safeApiDBConfig);
var Mongodb = require("./DBUtils/MongoDB");
var mongo = new Mongodb(bitcore.DBConfig.mongodbconfig);

var apiConfig = {};
var AsyncDBUtil = require("./DBUtils/asyncAddresses");
var AsyncBalance = require("./DBUtils/asyncBalance");

var index = require('../');
var errors = index.errors;
var log = index.log;
var utils = require('../utils');
var Service = require('../service');

var currHeight = 0;

/**
 * Provides a friendly event driven API to safed in Node.js. Manages starting and
 * stopping safed as a child process for application support, as well as connecting
 * to multiple safed processes for server infrastructure. Results are cached in an
 * LRU cache for improved performance and methods added for common queries.
 *
 * @param {Object} options
 * @param {Node} options.node - A reference to the node
 */
function Bitcoin(options) {
    if (!(this instanceof Bitcoin)) {
        return new Bitcoin(options);
    }

    Service.call(this, options);
    this.options = options;

    this._initCaches();

    // bitcoind child process
    this.spawn = false;

    // event subscribers
    this.subscriptions = {};
    this.subscriptions.rawtransaction = [];
    this.subscriptions.transactionlock = [];
    this.subscriptions.hashblock = [];
    this.subscriptions.address = {};

    // set initial settings
    this._initDefaults(options);

    // available safed nodes
    this._initClients();

    // for testing purposes
    this._process = options.process || process;
    this.depositFlag = false;
    this.on('error', function (err) {
        log.error(err.stack);
    });
}

util.inherits(Bitcoin, Service);

Bitcoin.dependencies = [];

Bitcoin.DEFAULT_MAX_TXIDS = 1000;
Bitcoin.DEFAULT_MAX_HISTORY = 50;
Bitcoin.DEFAULT_SHUTDOWN_TIMEOUT = 15000;
Bitcoin.DEFAULT_ZMQ_SUBSCRIBE_PROGRESS = 0.9999;
Bitcoin.DEFAULT_MAX_ADDRESSES_QUERY = 10000;
Bitcoin.DEFAULT_SPAWN_RESTART_TIME = 5000;
Bitcoin.DEFAULT_SPAWN_STOP_TIME = 10000;
Bitcoin.DEFAULT_TRY_ALL_INTERVAL = 1000;
Bitcoin.DEFAULT_REINDEX_INTERVAL = 10000;
Bitcoin.DEFAULT_START_RETRY_INTERVAL = 5000;
Bitcoin.DEFAULT_TIP_UPDATE_INTERVAL = 15000;
Bitcoin.DEFAULT_TRANSACTION_CONCURRENCY = 5;
Bitcoin.DEFAULT_INSTANTSEND_FEE = 100000;
Bitcoin.DEFAULT_CONFIG_SETTINGS = {
    server: 1,
    whitelist: '127.0.0.1',
    txindex: 1,
    addressindex: 1,
    timestampindex: 1,
    spentindex: 1,
    zmqpubrawtx: 'tcp://127.0.0.1:5553',
    zmqpubrawtxlock: 'tcp://127.0.0.1:5553',
    zmqpubhashblock: 'tcp://127.0.0.1:5553',
    rpcuser: 'rpcuser',
    rpcpassword: 'rpcpass',
    uacomment: 'bitcore',
    rpcport: 5556
};

Bitcoin.prototype._initDefaults = function (options) {
    /* jshint maxcomplexity: 15 */

    // limits
    this.maxTxids = options.maxTxids || Bitcoin.DEFAULT_MAX_TXIDS;
    this.maxTransactionHistory = options.maxTransactionHistory || Bitcoin.DEFAULT_MAX_HISTORY;
    this.maxAddressesQuery = options.maxAddressesQuery || Bitcoin.DEFAULT_MAX_ADDRESSES_QUERY;
    this.shutdownTimeout = options.shutdownTimeout || Bitcoin.DEFAULT_SHUTDOWN_TIMEOUT;

    // spawn restart setting
    this.spawnRestartTime = options.spawnRestartTime || Bitcoin.DEFAULT_SPAWN_RESTART_TIME;
    this.spawnStopTime = options.spawnStopTime || Bitcoin.DEFAULT_SPAWN_STOP_TIME;

    // try all interval
    this.tryAllInterval = options.tryAllInterval || Bitcoin.DEFAULT_TRY_ALL_INTERVAL;
    this.startRetryInterval = options.startRetryInterval || Bitcoin.DEFAULT_START_RETRY_INTERVAL;

    // rpc limits
    this.transactionConcurrency = options.transactionConcurrency || Bitcoin.DEFAULT_TRANSACTION_CONCURRENCY;

    // sync progress level when zmq subscribes to events
    this.zmqSubscribeProgress = options.zmqSubscribeProgress || Bitcoin.DEFAULT_ZMQ_SUBSCRIBE_PROGRESS;
};

Bitcoin.prototype._initCaches = function () {
    // caches valid until there is a new block
    this.utxosCache = LRU(50000);
    this.txidsCache = LRU(50000);
    this.balanceCache = LRU(50000);
    this.summaryCache = LRU(50000);
    this.blockOverviewCache = LRU(144);
    this.transactionDetailedCache = LRU(100000);

    // caches valid indefinitely
    this.transactionCache = LRU(100000);
    this.rawTransactionCache = LRU(50000);
    this.blockCache = LRU(144);
    this.rawBlockCache = LRU(72);
    this.blockHeaderCache = LRU(288);
    this.zmqKnownTransactions = LRU(5000);
    this.zmqKnownTransactionLocks = LRU(5000);
    this.zmqKnownBlocks = LRU(50);
    this.lastTip = 0;
    this.lastTipTimeout = false;
};

Bitcoin.prototype._initClients = function () {
    var self = this;
    this.nodes = [];
    this.nodesIndex = 0;
    Object.defineProperty(this, 'client', {
        get: function () {
            var client = self.nodes[self.nodesIndex].client;
            self.nodesIndex = (self.nodesIndex + 1) % self.nodes.length;
            return client;
        },
        enumerable: true,
        configurable: false
    });
};

/**
 * Called by Node to determine the available API methods.
 */
Bitcoin.prototype.getAPIMethods = function () {
    var methods = [
        ['getBlock', this, this.getBlock, 1],
        ['getRawBlock', this, this.getRawBlock, 1],
        ['getBlockHeader', this, this.getBlockHeader, 1],
        ['getBlockOverview', this, this.getBlockOverview, 1],
        ['getBlockHashesByTimestamp', this, this.getBlockHashesByTimestamp, 2],
        ['getBestBlockHash', this, this.getBestBlockHash, 0],
        ['getSpentInfo', this, this.getSpentInfo, 1],
        ['getInfo', this, this.getInfo, 0],
        ['syncPercentage', this, this.syncPercentage, 0],
        ['isSynced', this, this.isSynced, 0],
        ['getRawTransaction', this, this.getRawTransaction, 1],
        ['getTransaction', this, this.getTransaction, 1],
        ['getDetailedTransaction', this, this.getDetailedTransaction, 1],
        ['sendTransaction', this, this.sendTransaction, 1],
        ['estimateFee', this, this.estimateFee, 1],
        ['getAddressTxids', this, this.getAddressTxids, 2],
        ['getAddressBalance', this, this.getAddressBalance, 2],
        ['getAddressUnspentOutputs', this, this.getAddressUnspentOutputs, 2],
        ['getAddressHistory', this, this.getAddressHistory, 2],
        ['getAddressSummary', this, this.getAddressSummary, 1],
        ['generateBlock', this, this.generateBlock, 1],
        ['getMasterNode', this, this.getMasterNode, 0],
        ['getAssetsObj', this, this.getAssetsObj, 0],
        ['getAssetsList', this, this.getAssetsList, 0],
        ['getAssetsTranasctionList', this, this.getAssetsTranasctionList, 0],
        ['getAssetsTxList', this, this.getAssetsTxList, 0],
        ['getMasterNodeRate', this, this.getMasterNodeRate, 0],
        ['getRawTransactionJson', this, this.getRawTransactionJson, 0],
        ['getAddressAssetList', this, this.getAddressAssetList, 0],
        ['getAssetsTxAllList', this, this.getAssetsTxAllList, 0],
        ['getLockedAddressList', this, this.getLockedAddressList, 0],
        ['getLockedTransactionList', this, this.getLockedTransactionList, 0],
        ['getLockedAssetNameForMysql', this, this.getLockedAssetNameForMysql, 0],
        ['lockedDetailByAddressBit', this, this.lockedDetailByAddressBit, 0],
        ['getDepositFlag', this, this.getDepositFlag, 0],
        ['getAddressList', this, this.getAddressList, 0],
        ['getAssetLockedTotalAmount', this, this.getAssetLockedTotalAmount, 0],
        ['getBalanceRanking', this, this.getBalanceRanking, 0],
        ['getAmountStatistic', this, this.getAmountStatistic, 0],
        ['getMasterNodeRateCount', this, this.getMasterNodeRateCount, 0],
        ['getStatistic' , this,this.getStatistic,0],
        ['getTop100' , this,this.getTop100,0],
        ['getSeedAddress' , this,this.getSeedAddress,0],
        ['getVpnAddress' , this,this.getVpnAddress,0],
    ];
    return methods;
};

/**
 * Called by the Bus to determine the available events.
 */
Bitcoin.prototype.getPublishEvents = function () {
    return [
        {
            name: 'bitcoind/rawtransaction',
            scope: this,
            subscribe: this.subscribe.bind(this, 'rawtransaction'),
            unsubscribe: this.unsubscribe.bind(this, 'rawtransaction')
        },
        {
            name: 'bitcoind/transactionlock',
            scope: this,
            subscribe: this.subscribe.bind(this, 'transactionlock'),
            unsubscribe: this.unsubscribe.bind(this, 'transactionlock')
        },
        {
            name: 'bitcoind/hashblock',
            scope: this,
            subscribe: this.subscribe.bind(this, 'hashblock'),
            unsubscribe: this.unsubscribe.bind(this, 'hashblock')
        },
        {
            name: 'bitcoind/addresstxid',
            scope: this,
            subscribe: this.subscribeAddress.bind(this),
            unsubscribe: this.unsubscribeAddress.bind(this)
        }
    ];
};

Bitcoin.prototype.subscribe = function (name, emitter) {
    this.subscriptions[name].push(emitter);
    log.info(emitter.remoteAddress, 'subscribe:', 'bitcoind/' + name, 'total:', this.subscriptions[name].length);
};

Bitcoin.prototype.unsubscribe = function (name, emitter) {
    var index = this.subscriptions[name].indexOf(emitter);
    if (index > -1) {
        this.subscriptions[name].splice(index, 1);
    }
    log.info(emitter.remoteAddress, 'unsubscribe:', 'bitcoind/' + name, 'total:', this.subscriptions[name].length);
};

Bitcoin.prototype.subscribeAddress = function (emitter, addresses) {
    var self = this;

    function addAddress(addressStr) {
        if (self.subscriptions.address[addressStr]) {
            var emitters = self.subscriptions.address[addressStr];
            var index = emitters.indexOf(emitter);
            if (index === -1) {
                self.subscriptions.address[addressStr].push(emitter);
            }
        } else {
            self.subscriptions.address[addressStr] = [emitter];
        }
    }

    for (var i = 0; i < addresses.length; i++) {
        if (bitcore.Address.isValid(addresses[i], this.node.network)) {
            addAddress(addresses[i]);
        }
    }

    log.info(emitter.remoteAddress, 'subscribe:', 'bitcoind/addresstxid', 'total:', _.size(this.subscriptions.address));
};

Bitcoin.prototype.unsubscribeAddress = function (emitter, addresses) {
    var self = this;
    if (!addresses) {
        return this.unsubscribeAddressAll(emitter);
    }

    function removeAddress(addressStr) {
        var emitters = self.subscriptions.address[addressStr];
        var index = emitters.indexOf(emitter);
        if (index > -1) {
            emitters.splice(index, 1);
            if (emitters.length === 0) {
                delete self.subscriptions.address[addressStr];
            }
        }
    }

    for (var i = 0; i < addresses.length; i++) {
        if (this.subscriptions.address[addresses[i]]) {
            removeAddress(addresses[i]);
        }
    }

    log.info(emitter.remoteAddress, 'unsubscribe:', 'bitcoind/addresstxid', 'total:', _.size(this.subscriptions.address));
};

/**
 * A helper function for the `unsubscribe` method to unsubscribe from all addresses.
 * @param {EventEmitter} emitter - An instance of an event emitter
 */
Bitcoin.prototype.unsubscribeAddressAll = function (emitter) {
    for (var hashHex in this.subscriptions.address) {
        var emitters = this.subscriptions.address[hashHex];
        var index = emitters.indexOf(emitter);
        if (index > -1) {
            emitters.splice(index, 1);
        }
        if (emitters.length === 0) {
            delete this.subscriptions.address[hashHex];
        }
    }
    log.info(emitter.remoteAddress, 'unsubscribe:', 'bitcoind/addresstxid', 'total:', _.size(this.subscriptions.address));
};

Bitcoin.prototype._getDefaultConfig = function () {
    var config = '';
    var defaults = Bitcoin.DEFAULT_CONFIG_SETTINGS;
    for (var key in defaults) {
        config += key + '=' + defaults[key] + '\n';
    }
    return config;
};

Bitcoin.prototype._parseBitcoinConf = function (configPath) {
    var options = {};
    var file = fs.readFileSync(configPath);
    var unparsed = file.toString().split('\n');
    for (var i = 0; i < unparsed.length; i++) {
        var line = unparsed[i];
        if (!line.match(/^\#/) && line.match(/\=/)) {
            var option = line.split('=');
            var value;
            if (!Number.isNaN(Number(option[1]))) {
                value = Number(option[1]);
            } else {
                value = option[1];
            }
            options[option[0]] = value;
        }
    }
    return options;
};

Bitcoin.prototype._expandRelativeDatadir = function () {
    if (!utils.isAbsolutePath(this.options.spawn.datadir)) {
        $.checkState(this.node.configPath);
        $.checkState(utils.isAbsolutePath(this.node.configPath));
        var baseConfigPath = path.dirname(this.node.configPath);
        this.options.spawn.datadir = path.resolve(baseConfigPath, this.options.spawn.datadir);
    }
};

Bitcoin.prototype._loadSpawnConfiguration = function (node) {
    /* jshint maxstatements: 25 */

    $.checkArgument(this.options.spawn, 'Please specify "spawn" in safed config options');
    $.checkArgument(this.options.spawn.datadir, 'Please specify "spawn.datadir" in safed config options');
    $.checkArgument(this.options.spawn.exec, 'Please specify "spawn.exec" in safed config options');

    this._expandRelativeDatadir();

    var spawnOptions = this.options.spawn;
    var configPath = path.resolve(spawnOptions.datadir, './safe.conf');

    log.info('Using bitcoin config file:', configPath);

    this.spawn = {};
    this.spawn.datadir = this.options.spawn.datadir;
    this.spawn.exec = this.options.spawn.exec;
    this.spawn.configPath = configPath;
    this.spawn.config = {};

    if (!fs.existsSync(spawnOptions.datadir)) {
        mkdirp.sync(spawnOptions.datadir);
    }

    if (!fs.existsSync(configPath)) {
        var defaultConfig = this._getDefaultConfig();
        fs.writeFileSync(configPath, defaultConfig);
    }

    var safeConf = this._parseBitcoinConf(configPath);

    apiConfig = {
        port: safeConf.rpcport + ""
    };
    _.extend(this.spawn.config, this._getDefaultConf(safeConf));
    _.extend(this.spawn.config, safeConf);

    var networkConfigPath = this._getNetworkConfigPath();
    if (networkConfigPath && fs.existsSync(networkConfigPath)) {
        _.extend(this.spawn.config, this._parseBitcoinConf(networkConfigPath));
    }

    var spawnConfig = this.spawn.config;
    this._checkConfigIndexes(spawnConfig, node);
};

Bitcoin.prototype._checkConfigIndexes = function (spawnConfig, node) {
    $.checkState(
        spawnConfig.txindex && spawnConfig.txindex === 1,
        '"txindex" option is required in order to use transaction query features of bitcore-node-safe. ' +
        'Please add "txindex=1" to your configuration and reindex an existing database if ' +
        'necessary with reindex=1'
    );

    $.checkState(
        spawnConfig.addressindex && spawnConfig.addressindex === 1,
        '"addressindex" option is required in order to use address query features of bitcore-node-safe. ' +
        'Please add "addressindex=1" to your configuration and reindex an existing database if ' +
        'necessary with reindex=1'
    );

    $.checkState(
        spawnConfig.spentindex && spawnConfig.spentindex === 1,
        '"spentindex" option is required in order to use spent info query features of bitcore-node-safe. ' +
        'Please add "spentindex=1" to your configuration and reindex an existing database if ' +
        'necessary with reindex=1'
    );

    $.checkState(
        spawnConfig.server && spawnConfig.server === 1,
        '"server" option is required to communicate to safed from bitcore. ' +
        'Please add "server=1" to your configuration and restart'
    );

    $.checkState(
        spawnConfig.zmqpubrawtx,
        '"zmqpubrawtx" option is required to get event updates from safed. ' +
        'Please add "zmqpubrawtx=tcp://127.0.0.1:<port>" to your configuration and restart'
    );

    $.checkState(
        spawnConfig.zmqpubrawtxlock,
        '"zmqpubrawtxlock" option is required to get transaction locks from safed. ' +
        'Please add "zmqpubrawtxlock=tcp://127.0.0.1:<port>" to your configuration and restart'
    );

    $.checkState(
        spawnConfig.zmqpubhashblock,
        '"zmqpubhashblock" option is required to get event updates from safed. ' +
        'Please add "zmqpubhashblock=tcp://127.0.0.1:<port>" to your configuration and restart'
    );

    $.checkState(
        (spawnConfig.zmqpubhashblock === spawnConfig.zmqpubrawtx),
        '"zmqpubrawtx" and "zmqpubhashblock" are expected to the same host and port in bitcoin.conf'
    );

    if (spawnConfig.reindex && spawnConfig.reindex === 1) {
        log.warn('Reindex option is currently enabled. This means that safed is undergoing a reindex. ' +
            'The reindex flag will start the index from beginning every time the node is started, so it ' +
            'should be removed after the reindex has been initiated. Once the reindex is complete, the rest ' +
            'of bitcore-node-safe services will start.');
        node._reindex = true;
    }
};

Bitcoin.prototype._resetCaches = function () {
    this.transactionDetailedCache.reset();
    this.utxosCache.reset();
    this.txidsCache.reset();
    this.balanceCache.reset();
    this.summaryCache.reset();
    this.blockOverviewCache.reset();
};

Bitcoin.prototype._tryAllClients = function (func, callback) {
    var self = this;
    var nodesIndex = this.nodesIndex;
    var retry = function (done) {
        var client = self.nodes[nodesIndex].client;
        nodesIndex = (nodesIndex + 1) % self.nodes.length;
        func(client, done);
    };
    async.retry({times: this.nodes.length, interval: this.tryAllInterval || 1000}, retry, callback);
};

Bitcoin.prototype._wrapRPCError = function (errObj) {
    var err = new errors.RPCError(errObj.message);
    err.code = errObj.code;
    return err;
};

Bitcoin.prototype._initChain = function (callback) {
    var self = this;
    self.client.getBestBlockHash(function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        self.client.getBlock(response.result, function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            self.height = response.result.height;
            self.client.getBlockHash(0, function (err, response) {
                if (err) {
                    return callback(self._wrapRPCError(err));
                }
                // var blockhash = response.result;
                self.getRawBlock(response.result, function (err, blockBuffer) {
                    if (err) {
                        return callback(err);
                    }
                    self.genesisBuffer = blockBuffer;
                    self.emit('ready');
                    log.info('SAFE Daemon Ready');
                    callback();
                });
            });
        });
    });
};

Bitcoin.prototype._getDefaultConf = function (conf) {
    var networkOptions = {
        rpcport: conf.rpcport || 5556
    };
    if (this.node.network === bitcore.Networks.testnet) {
        networkOptions.rpcport = 19998;
    }
    return networkOptions;
};

Bitcoin.prototype._getNetworkConfigPath = function () {
    var networkPath;
    if (this.node.network === bitcore.Networks.testnet) {
        networkPath = 'testnet3/safe.conf';
        if (this.node.network.regtestEnabled) {
            networkPath = 'regtest/safe.conf';
        }
    }
    return networkPath;
};

Bitcoin.prototype._getNetworkOption = function () {
    var networkOption;
    if (this.node.network === bitcore.Networks.testnet) {
        networkOption = '--testnet';
        if (this.node.network.regtestEnabled) {
            networkOption = '--regtest';
        }
    }
    return networkOption;
};

Bitcoin.prototype._zmqBlockHandler = function (node, message) {
    var self = this;
    // Update the current chain tip
    self._rapidProtectedUpdateTip(node, message);
    // Notify block subscribers
    var id = message.toString('binary');
    if (!self.zmqKnownBlocks.get(id)) {
        self.zmqKnownBlocks.set(id, true);
        self.isDepositFlag();
        self.emit('block', message);

        for (var i = 0; i < this.subscriptions.hashblock.length; i++) {
            this.subscriptions.hashblock[i].emit('bitcoind/hashblock', message.toString('hex'));
        }
    }

};

Bitcoin.prototype._rapidProtectedUpdateTip = function (node, message) {
    var self = this;

    // Prevent a rapid succession of tip updates
    if (new Date() - self.lastTip > 1000) {
        self.lastTip = new Date();
        self._updateTip(node, message);
    } else {
        clearTimeout(self.lastTipTimeout);
        self.lastTipTimeout = setTimeout(function () {
            self._updateTip(node, message);
        }, 1000);
    }
};

Bitcoin.prototype._updateTip = function (node, message) {
    var self = this;

    var hex = message.toString('hex');
    if (hex !== self.tiphash) {
        self.tiphash = message.toString('hex');

        // reset block valid caches
        self._resetCaches();
        node.client.getBlock(self.tiphash, function (err, response) {
            if (err) {
                var error = self._wrapRPCError(err);
                self.emit('error', error);
            } else {
                self.height = response.result.height;
                $.checkState(self.height >= 0);
                self.emit('tip', self.height);
            }
        });
        if (!self.node.stopping) {
            self.syncPercentage(function (err, percentage) {
                if (err) {
                    self.emit('error', err);
                } else {
                    if (Math.round(percentage) >= 100) {
                        self.emit('synced', self.height);
                    }
                    currHeight = self.height - 1;
                    self.isDepositFlag(); //启动时判断是否到达封存条件
                    log.info('Safe Height:', self.height, 'Percentage:', percentage.toFixed(2));
                }
            });
        }
    }
};

Bitcoin.prototype._getAddressesFromTransaction = function (transaction) {
    var addresses = [];

    for (var i = 0; i < transaction.inputs.length; i++) {
        var input = transaction.inputs[i];
        if (input.script) {
            var inputAddress = input.script.toAddress(this.node.network);
            if (inputAddress) {
                addresses.push(inputAddress.toString());
            }
        }
    }
    for (var j = 0; j < transaction.outputs.length; j++) {
        var output = transaction.outputs[j];
        if (output.script) {
            var outputAddress = output.script.toAddress(this.node.network);
            if (outputAddress) {
                addresses.push(outputAddress.toString());
            }
        }
    }

    return _.uniq(addresses);
};

Bitcoin.prototype._notifyAddressTxidSubscribers = function (txid, transaction) {
    var addresses = this._getAddressesFromTransaction(transaction);
    for (var i = 0; i < addresses.length; i++) {
        var address = addresses[i];
        if (this.subscriptions.address[address]) {
            var emitters = this.subscriptions.address[address];
            for (var j = 0; j < emitters.length; j++) {
                emitters[j].emit('bitcoind/addresstxid', {
                    address: address,
                    txid: txid
                });
            }
        }
    }
};

Bitcoin.prototype._zmqTransactionHandler = function (node, message) {
    var self = this;
    var hash = bitcore.crypto.Hash.sha256sha256(message);
    var id = hash.toString('binary');
    if (!self.zmqKnownTransactions.get(id)) {
        self.zmqKnownTransactions.set(id, true);
        self.emit('tx', message);
        // Notify transaction subscribers
        for (var i = 0; i < this.subscriptions.rawtransaction.length; i++) {
            this.subscriptions.rawtransaction[i].emit('bitcoind/rawtransaction', message.toString('hex'));
        }

        var tx = bitcore.Transaction();
        tx.fromString(message);
        var txid = bitcore.util.buffer.reverse(hash).toString('hex');
        self._notifyAddressTxidSubscribers(txid, tx);
    }
};

Bitcoin.prototype._zmqTransactionLockHandler = function (node, message) {
    var self = this;
    var hash = bitcore.crypto.Hash.sha256sha256(message);
    var id = hash.toString('binary');
    if (!self.zmqKnownTransactionLocks.get(id)) {
        self.zmqKnownTransactionLocks.set(id, true);
        self.emit('txlock', message);

        // Notify transaction lock subscribers
        for (var i = 0; i < this.subscriptions.transactionlock.length; i++) {
            this.subscriptions.transactionlock[i].emit('bitcoind/transactionlock', message.toString('hex'));
        }
    }
};

Bitcoin.prototype._checkSyncedAndSubscribeZmqEvents = function (node) {
    var self = this;
    var interval;

    function checkAndSubscribe(callback) {
        // update tip
        node.client.getBestBlockHash(function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            var blockhash = new Buffer(response.result, 'hex');
            self.emit('block', blockhash);
            self._updateTip(node, blockhash);

            // check if synced
            node.client.getBlockchainInfo(function (err, response) {
                if (err) {
                    return callback(self._wrapRPCError(err));
                }
                var progress = response.result.verificationprogress;
                if (progress >= self.zmqSubscribeProgress) {
                    // subscribe to events for further updates
                    
                    var asyncAddress = new AsyncDBUtil(apiConfig, DB, bitcore.sendRequseConf);
                    asyncAddress.start();
                    var asyncBalance = new AsyncBalance( DB, apiConfig );
                    asyncBalance.start();

                    self._subscribeZmqEvents(node);
                    clearInterval(interval);
                    callback(null, true);
                } else {
                    callback(null, false);
                }
            });
        });
    }

    checkAndSubscribe(function (err, synced) {
        if (err) {
            log.error(err);
        }
        if (!synced) {
            interval = setInterval(function () {
                if (self.node.stopping) {
                    return clearInterval(interval);
                }
                checkAndSubscribe(function (err) {
                    if (err) {
                        log.error(err);
                    }
                });
            }, node._tipUpdateInterval || Bitcoin.DEFAULT_TIP_UPDATE_INTERVAL);
        }
    });

};

Bitcoin.prototype._subscribeZmqEvents = function (node) {
    var self = this;
    node.zmqSubSocket.subscribe('hashblock');
    node.zmqSubSocket.subscribe('rawtx');
    node.zmqSubSocket.subscribe('rawtxlock');
    node.zmqSubSocket.on('message', function (topic, message) {
        var topicString = topic.toString('utf8');
        if (topicString === 'rawtxlock') {
            self._zmqTransactionLockHandler(node, message);
        } else if (topicString === 'rawtx') {
            self._zmqTransactionHandler(node, message);
        } else if (topicString === 'hashblock') {
            self._zmqBlockHandler(node, message);
        }
    });
};

Bitcoin.prototype._initZmqSubSocket = function (node, zmqUrl) {
    var self = this;
    node.zmqSubSocket = zmq.socket('sub');

    node.zmqSubSocket.on('connect', function (fd, endPoint) {
        log.info('ZMQ connected to:', endPoint);
    });

    node.zmqSubSocket.on('connect_delay', function (fd, endPoint) {
        log.warn('ZMQ connection delay:', endPoint);
    });

    node.zmqSubSocket.on('disconnect', function (fd, endPoint) {
        log.warn('ZMQ disconnect:', endPoint);
    });

    node.zmqSubSocket.on('monitor_error', function (err) {
        log.error('Error in monitoring: %s, will restart monitoring in 5 seconds', err);
        setTimeout(function () {
            self.zmqSubSocket.monitor(500, 0);
        }, 5000);
    });

    node.zmqSubSocket.monitor(500, 0);
    node.zmqSubSocket.connect(zmqUrl);
};

Bitcoin.prototype._checkReindex = function (node, callback) {
    var self = this;
    var interval;

    function finish(err) {
        clearInterval(interval);
        callback(err);
    }

    if (node._reindex) {
        interval = setInterval(function () {
            node.client.getBlockchainInfo(function (err, response) {
                if (err) {
                    return finish(self._wrapRPCError(err));
                }
                var percentSynced = response.result.verificationprogress * 100;

                log.info('Safe Core Daemon Reindex Percentage: ' + percentSynced.toFixed(2));
                if (Math.round(percentSynced) >= 100) {
                    node._reindex = false;
                    finish();
                }
            });
        }, node._reindexWait || Bitcoin.DEFAULT_REINDEX_INTERVAL);
    } else {
        callback();
    }
};

Bitcoin.prototype._loadTipFromNode = function (node, callback) {
    var self = this;
    node.client.getBestBlockHash(function (err, response) {
        if (err && err.code === -28) {
            log.warn(err.message);
            return callback(self._wrapRPCError(err));
        } else if (err) {
            return callback(self._wrapRPCError(err));
        }
        node.client.getBlock(response.result, function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            self.height = response.result.height;
            $.checkState(self.height >= 0);
            self.emit('tip', self.height);
            callback();
        });
    });
};

Bitcoin.prototype._stopSpawnedBitcoin = function (callback) {
    var self = this;
    var spawnOptions = this.options.spawn;
    var pidPath = spawnOptions.datadir + '/safed.pid';

    function stopProcess() {
        fs.readFile(pidPath, 'utf8', function (err, pid) {
            if (err && err.code === 'ENOENT') {
                // pid file doesn't exist we can continue
                return callback(null);
            } else if (err) {
                return callback(err);
            }
            pid = parseInt(pid);
            if (!Number.isFinite(pid)) {
                // pid doesn't exist we can continue
                return callback(null);
            }
            try {
                log.warn('Stopping existing spawned safe process with pid: ' + pid);
                self._process.kill(pid, 'SIGINT');
            } catch (err) {
                if (err && err.code === 'ESRCH') {
                    log.warn('Unclean safe process shutdown, process not found with pid: ' + pid);
                    return callback(null);
                } else if (err) {
                    return callback(err);
                }
            }
            setTimeout(function () {
                stopProcess();
            }, self.spawnStopTime);
        });
    }

    stopProcess();
};

Bitcoin.prototype._spawnChildProcess = function (callback) {
    var self = this;

    var node = {};
    node._reindex = false;
    node._reindexWait = 10000;

    try {
        self._loadSpawnConfiguration(node);
    } catch (e) {
        return callback(e);
    }

    var options = [
        '--conf=' + this.spawn.configPath,
        '--datadir=' + this.spawn.datadir
    ];

    if (self._getNetworkOption()) {
        options.push(self._getNetworkOption());
    }

    self._stopSpawnedBitcoin(function (err) {
        if (err) {
            return callback(err);
        }

        log.info('Starting safe process');
        self.spawn.process = spawn(self.spawn.exec, options, {stdio: 'inherit'});

        self.spawn.process.on('error', function (err) {
            self.emit('error', err);
        });

        self.spawn.process.once('exit', function (code) {
            if (!self.node.stopping) {
                log.warn('Safe process unexpectedly exited with code:', code);
                log.warn('Restarting safe child process in ' + self.spawnRestartTime + 'ms');
                setTimeout(function () {
                    self._spawnChildProcess(function (err) {
                        if (err) {
                            return self.emit('error', err);
                        }
                        log.warn('Safe process restarted');
                    });
                }, self.spawnRestartTime);
            }
        });

        var exitShutdown = false;

        async.retry({times: 60, interval: self.startRetryInterval}, function (done) {
            if (self.node.stopping) {
                exitShutdown = true;
                return done();
            }

            node.client = new BitcoinRPC({
                protocol: 'http',
                host: '127.0.0.1',
                port: self.spawn.config.rpcport,
                user: self.spawn.config.rpcuser,
                pass: self.spawn.config.rpcpassword
            });

            self._loadTipFromNode(node, done);

        }, function (err) {
            if (err) {
                return callback(err);
            }
            if (exitShutdown) {
                return callback(new Error('Stopping while trying to spawn safed.'));
            }

            self._initZmqSubSocket(node, self.spawn.config.zmqpubrawtx);

            self._checkReindex(node, function (err) {
                if (err) {
                    return callback(err);
                }
                self._checkSyncedAndSubscribeZmqEvents(node);
                callback(null, node);
            });

        });

    });

};

Bitcoin.prototype._connectProcess = function (config, callback) {
    var self = this;
    var node = {};
    var exitShutdown = false;

    async.retry({times: 60, interval: self.startRetryInterval}, function (done) {
        if (self.node.stopping) {
            exitShutdown = true;
            return done();
        }
        node.client = new BitcoinRPC({
            protocol: config.rpcprotocol || 'http',
            host: config.rpchost || '127.0.0.1',
            port: config.rpcport,
            user: config.rpcuser,
            pass: config.rpcpassword,
            rejectUnauthorized: _.isUndefined(config.rpcstrict) ? true : config.rpcstrict
        });
        self._loadTipFromNode(node, done);
    }, function (err) {
        if (err) {
            return callback(err);
        }
        if (exitShutdown) {
            return callback(new Error('Stopping while trying to connect to safed.'));
        }

        self._initZmqSubSocket(node, config.zmqpubrawtx);
        self._subscribeZmqEvents(node);
        callback(null, node);
    });
};

/**
 * Called by Node to start the service
 * @param {Function} callback
 */
Bitcoin.prototype.start = function (callback) {
    var self = this;
    async.series([
        function (next) {
            if (self.options.spawn) {
                self._spawnChildProcess(function (err, node) {
                    if (err) {
                        return next(err);
                    }
                    self.nodes.push(node);
                    next();
                });
            } else {
                next();
            }
        },
        function (next) {
            if (self.options.connect) {
                async.map(self.options.connect, self._connectProcess.bind(self), function (err, nodes) {
                    if (err) {
                        return callback(err);
                    }
                    for (var i = 0; i < nodes.length; i++) {
                        self.nodes.push(nodes[i]);
                    }
                    next();
                });
            } else {
                next();
            }
        }
    ], function (err) {
        if (err) {
            return callback(err);
        }
        if (self.nodes.length === 0) {
            return callback(new Error('Bitcoin configuration options "spawn" or "connect" are expected'));
        }
        self._initChain(callback);
    });

};

/**
 * Helper to determine the state of the database.
 * @param {Function} callback
 */
Bitcoin.prototype.isSynced = function (callback) {
    this.syncPercentage(function (err, percentage) {
        if (err) {
            return callback(err);
        }
        if (Math.round(percentage) >= 100) {
            callback(null, true);
        } else {
            callback(null, false);
        }
    });
};

/**
 * Helper to determine the progress of the database.
 * @param {Function} callback
 */
Bitcoin.prototype.syncPercentage = function (callback) {
    var self = this;
    this.client.getBlockchainInfo(function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        var percentSynced = response.result.verificationprogress * 100;
        callback(null, percentSynced);
    });
};

Bitcoin.prototype._normalizeAddressArg = function (addressArg) {
    var addresses = [addressArg];
    if (Array.isArray(addressArg)) {
        addresses = addressArg;
    }
    return addresses;
};

/**
 * Will get the balance for an address or multiple addresses
 * @param {String|Address|Array} addressArg - An address string, bitcore address, or array of addresses
 * @param {Object} options
 * @param {Function} callback
 */
Bitcoin.prototype.getAddressBalance = function (addressArg, options, callback) {
    var self = this;
    var addresses = self._normalizeAddressArg(addressArg);
    if (options.assetsId) { // 地址资产余额
        self.client.getaddrassetbalance(addressArg, options.assetsId, function (err, response) {   //获取地址某资产的余额
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            var amount = {
                balance: response.result.totalAmount,       //总余额
                received: response.result.ReceiveAmount,    //总接送
                lock: response.result.lockAmount,            //总锁定
                depositAmount: 0
            };
            callback(null, amount);
        });
    } else { // 地址safe 余额
        self.client.getAddressBalance({addresses: addresses}, function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }

            var result = {
                balance: response.result.balance / 100000000,   // 总余额
                received: response.result.received / 100000000, // 总接收
                lock: response.result.lockamount / 100000000,    //总锁定
                depositAmount: 0
            };
            self.getDepositFlag(function (depositFlag) {
                if (!depositFlag) {
                    callback(null, result);
                } else {
                    mongo.getDepositAmountForAddress(addresses[0], function (err, depositAmount) {
                        result.depositAmount = depositAmount;
                        callback(null, result);
                    })
                }
            });

        });
    }
};

/**
 * Will get the unspent outputs for an address or multiple addresses
 * @param {String|Address|Array} addressArg - An address string, bitcore address, or array of addresses
 * @param {Object} options
 * @param {Function} callback
 */
Bitcoin.prototype.getAddressUnspentOutputs = function (addressArg, options, callback) {
    var self = this;
    var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;
    var addresses = self._normalizeAddressArg(addressArg);
    var cacheKey = addresses.join('');
    var utxos = self.utxosCache.get(cacheKey);

    function transformUnspentOutput(delta) {
        var script = bitcore.Script.fromAddress(delta.address);
        return {
            address: delta.address,
            txid: delta.txid,
            outputIndex: delta.index,
            script: script.toHex(),
            satoshis: delta.satoshis,
            timestamp: delta.timestamp
        };
    }

    function updateWithMempool(confirmedUtxos, mempoolDeltas) {
        /* jshint maxstatements: 20 */
        if (!mempoolDeltas || !mempoolDeltas.length) {
            return confirmedUtxos;
        }
        var isSpentOutputs = false;
        var mempoolUnspentOutputs = [];
        var spentOutputs = [];

        for (var i = 0; i < mempoolDeltas.length; i++) {
            var delta = mempoolDeltas[i];
            if (delta.prevtxid && delta.satoshis <= 0) {
                if (!spentOutputs[delta.prevtxid]) {
                    spentOutputs[delta.prevtxid] = [delta.prevout];
                } else {
                    spentOutputs[delta.prevtxid].push(delta.prevout);
                }
                isSpentOutputs = true;
            } else {
                mempoolUnspentOutputs.push(transformUnspentOutput(delta));
            }
        }

        var utxos = mempoolUnspentOutputs.reverse().concat(confirmedUtxos);

        if (isSpentOutputs) {
            return utxos.filter(function (utxo) {
                if (!spentOutputs[utxo.txid]) {
                    return true;
                } else {
                    return (spentOutputs[utxo.txid].indexOf(utxo.outputIndex) === -1);
                }
            });
        }

        return utxos;
    }

    function finish(mempoolDeltas) {
        if (utxos) {
            return setImmediate(function () {
                callback(null, updateWithMempool(utxos, mempoolDeltas));
            });
        } else {
            self.client.getAddressUtxos({addresses: addresses}, function (err, response) {
                if (err) {
                    return callback(self._wrapRPCError(err));
                }
                var utxos = response.result.reverse();
                self.utxosCache.set(cacheKey, utxos);
                callback(null, updateWithMempool(utxos, mempoolDeltas));
            });
        }
    }

    if (queryMempool) {
        self.client.getAddressMempool({addresses: addresses}, function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            finish(response.result);
        });
    } else {
        finish();
    }

};

Bitcoin.prototype._getBalanceFromMempool = function (deltas) {
    var satoshis = 0;
    for (var i = 0; i < deltas.length; i++) {
        satoshis += deltas[i].satoshis;
    }
    return satoshis;
};

Bitcoin.prototype._getTxidsFromMempool = function (deltas) {
    var mempoolTxids = [];
    var mempoolTxidsKnown = {};
    for (var i = 0; i < deltas.length; i++) {
        var txid = deltas[i].txid;
        if (!mempoolTxidsKnown[txid]) {
            mempoolTxids.push(txid);
            mempoolTxidsKnown[txid] = true;
        }
    }
    return mempoolTxids;
};

Bitcoin.prototype._getHeightRangeQuery = function (options, clone) {
    if (options.start >= 0 && options.end >= 0) {
        if (options.end > options.start) {
            throw new TypeError('"end" is expected to be less than or equal to "start"');
        }
        if (clone) {
            // reverse start and end as the order in bitcore is most recent to less recent
            clone.start = options.end;
            clone.end = options.start;
        }
        return true;
    }
    return false;
};

/**
 * Will get the txids for an address or multiple addresses
 * @param {String|Address|Array} addressArg - An address string, bitcore address, or array of addresses
 * @param {Object} options
 * @param {Function} callback
 */
Bitcoin.prototype.getAddressTxids = function (addressArg, options, callback) {
    /* jshint maxstatements: 16 */
    var self = this;
    var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;
    var rangeQuery = false;
    try {
        rangeQuery = self._getHeightRangeQuery(options);
    } catch (err) {
        return callback(err);
    }
    if (rangeQuery) {
        queryMempool = false;
    }
    var addresses = self._normalizeAddressArg(addressArg);
    var cacheKey = addresses.join('') + options.assetsId || "";
    var mempoolTxids = [];
    var txids = self.txidsCache.get(cacheKey);

    function finish() {
        if (txids && !rangeQuery) {
            var allTxids = mempoolTxids.reverse().concat(txids);
            return setImmediate(function () {
                callback(null, allTxids);
            });
        } else {
            var txidOpts = {
                addresses: addresses
            };
            if (rangeQuery) {
                self._getHeightRangeQuery(options, txidOpts);
            }
            self.client.getAddressTxids(txidOpts, function (err, response) {
                if (err) {
                    return callback(self._wrapRPCError(err));
                }
                response.result.reverse();
                if (!rangeQuery) {
                    self.txidsCache.set(cacheKey, response.result);
                }
                var allTxids = mempoolTxids.reverse().concat(response.result);
                return callback(null, allTxids);
            });
        }
    }

    if (queryMempool) {
        self.client.getAddressMempool({addresses: addresses}, function (err, response) {
            if (err) {
                return callback(self._wrapRPCError(err));
            }
            mempoolTxids = self._getTxidsFromMempool(response.result);
            finish();
        });
    } else {
        finish();
    }

};

Bitcoin.prototype._getConfirmationsDetail = function (transaction) {
    $.checkState(this.height > 0, 'current height is unknown');
    var confirmations = 0;
    if (transaction.height >= 0) {
        confirmations = this.height - transaction.height + 1;
    }
    if (confirmations < 0) {
        log.warn('Negative confirmations calculated for transaction:', transaction.hash);
    }
    return Math.max(0, confirmations);
};

Bitcoin.prototype._getAddressDetailsForInput = function (input, inputIndex, result, addressStrings) {
    if (!input.address) {
        return;
    }
    var address = input.address;
    if (addressStrings.indexOf(address) >= 0) {
        if (!result.addresses[address]) {
            result.addresses[address] = {
                inputIndexes: [inputIndex],
                outputIndexes: []
            };
        } else {
            result.addresses[address].inputIndexes.push(inputIndex);
        }
        result.satoshis -= parseFloat(input.satoshis);
    }
};

Bitcoin.prototype._getAddressDetailsForOutput = function (output, outputIndex, result, addressStrings) {
    if (!output.address) {
        return;
    }
    var address = output.address;
    if (addressStrings.indexOf(address) >= 0) {
        if (!result.addresses[address]) {
            result.addresses[address] = {
                inputIndexes: [],
                outputIndexes: [outputIndex]
            };
        } else {
            result.addresses[address].outputIndexes.push(outputIndex);
        }
        result.satoshis += parseFloat(output.satoshis);
    }
};

Bitcoin.prototype._getAddressDetailsForTransaction = function (transaction, addressStrings) {
    var result = {
        addresses: {},
        satoshis: 0
    };
    for (var inputIndex = 0; inputIndex < transaction.inputs.length; inputIndex++) {
        var input = transaction.inputs[inputIndex];
        this._getAddressDetailsForInput(input, inputIndex, result, addressStrings);
    }

    for (var outputIndex = 0; outputIndex < transaction.outputs.length; outputIndex++) {
        var output = transaction.outputs[outputIndex];
        this._getAddressDetailsForOutput(output, outputIndex, result, addressStrings);
    }
    $.checkState(Number.isFinite(result.satoshis));
    return result;
};

/**
 * Will expand into a detailed transaction from a txid
 * @param txid
 * @param options
 * @param next
 */
Bitcoin.prototype._getAddressDetailedTransaction = function (txid, options, next) {
    var self = this;

    self.getDetailedTransaction(txid, function (err, transaction) {
            if (err) {
                return next(err);
            }
            var addressDetails = self._getAddressDetailsForTransaction(transaction, options.addressStrings);

            var details = {
                addresses: addressDetails.addresses,
                satoshis: addressDetails.satoshis,
                confirmations: self._getConfirmationsDetail(transaction),
                tx: transaction
            };
            next(null, details);
        }
    );
};

Bitcoin.prototype._getAddressStrings = function (addresses) {
    var addressStrings = [];
    for (var i = 0; i < addresses.length; i++) {
        var address = addresses[i];
        if (address instanceof bitcore.Address) {
            addressStrings.push(address.toString());
        } else if (_.isString(address)) {
            addressStrings.push(address);
        } else {
            throw new TypeError('Addresses are expected to be strings');
        }
    }
    return addressStrings;
};

Bitcoin.prototype._paginateTxids = function (fullTxids, fromArg, toArg) {
    var txids;
    var from = parseInt(fromArg);
    var to = parseInt(toArg);
    $.checkState(from < to, '"from" (' + from + ') is expected to be less than "to" (' + to + ')');
    txids = fullTxids.slice(from, to);
    return txids;
};

/**
 * Will detailed transaction history for an address or multiple addresses
 * @param {String|Address|Array} addressArg - An address string, bitcore address, or array of addresses
 * @param {Object} options
 * @param {Function} callback
 */
Bitcoin.prototype.getAddressHistory = function (addressArg, options, callback) {
    var self = this;
    var addresses = self._normalizeAddressArg(addressArg);
    if (addresses.length > this.maxAddressesQuery) {
        return callback(new TypeError('Maximum number of addresses (' + this.maxAddressesQuery + ') exceeded'));
    }

    var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;
    var addressStrings = this._getAddressStrings(addresses);

    var fromArg = parseInt(options.from || 0);
    var toArg = parseInt(options.to || self.maxTransactionHistory);

    if ((toArg - fromArg) > self.maxTransactionHistory) {
        return callback(new Error(
            '"from" (' + options.from + ') and "to" (' + options.to + ') range should be less than or equal to ' +
            self.maxTransactionHistory
        ));
    }

    if (options.assetsId && options.assetsId != "all") {
        self.getAddressAssetsTransactionList(addresses[0], options.assetsId, function (err, txids) {
            var totalCount = txids.length;
            try {
                txids = self._paginateTxids(txids, fromArg, toArg);
            } catch (e) {
                return callback(e);
            }
            self.getTranasctionsDetailForTxids(txids, queryMempool, addressStrings, function (err, transactions) {
                callback(null, {
                    totalCount: totalCount,
                    items: transactions
                });
            })
        })
    } else {
        self.getAddressTxids(addresses, options, function (err, txids) {
            if (err) {
                return callback(err);
            }
            var totalCount = txids.length;
            try {
                txids = self._paginateTxids(txids, fromArg, toArg);
            } catch (e) {
                return callback(e);
            }
            self.getTranasctionsDetailForTxids(txids, queryMempool, addressStrings, function (err, transactions) {
                callback(null, {
                    totalCount: totalCount,
                    items: transactions
                });
            })
        });
    }
};

Bitcoin.prototype.getTranasctionsDetailForTxids = function (txids, queryMempool, addressStrings, callback) {
    var self = this;
    async.mapLimit(
        txids,
        self.transactionConcurrency,
        function (txid, next) {
            self._getAddressDetailedTransaction(txid, {
                queryMempool: queryMempool,
                addressStrings: addressStrings
            }, next);
        },
        function (err, transactions) {
            if (err) {
                return callback(err);
            }
            callback(null, transactions)
        }
    );
};

Bitcoin.prototype.getAddressHistoryNew = function (addressArg, options, callback) {
    var self = this;
    var addresses = self._normalizeAddressArg(addressArg);
    if (addresses.length > this.maxAddressesQuery) {
        return callback(new TypeError('Maximum number of addresses (' + this.maxAddressesQuery + ') exceeded'));
    }
    var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;
    var addressStrings = this._getAddressStrings(addresses);
    var fromArg = parseInt(options.from || 0);
    var toArg = parseInt(options.to || self.maxTransactionHistory);

    if ((toArg - fromArg) > self.maxTransactionHistory) {
        return callback(new Error(
            '"from" (' + options.from + ') and "to" (' + options.to + ') range should be less than or equal to ' +
            self.maxTransactionHistory
        ));
    }
    db.txInAddress.find({'address': addressArg}).sort({"timestamp": -1}).skip(fromArg).limit(11).toArray(function (err, txidList) {
        if (err) {
            return callback(err);
        }
        var totalCount = parseInt(fromArg) + 10;
        if (txidList) {
            if (txidList.length === 11) {
                totalCount = parseInt(fromArg) + txidList.length;
                txidList.pop();
            } else {
                totalCount = parseInt(fromArg) + txidList.length;
            }
        }
        async.mapLimit(
            txidList,
            self.transactionConcurrency,
            function (tx, next) {
                self._getAddressDetailedTransaction(tx.txid, {
                    queryMempool: queryMempool,
                    addressStrings: addressStrings
                }, next);
            },
            function (err, transactions) {
                if (err) {
                    return callback(err);
                }
                callback(null, {
                    totalCount: totalCount,
                    items: transactions
                });
            }
        );
    });
};

/**
 * Will get the summary including txids and balance for an address or multiple addresses
 * @param {String|Address|Array} addressArg - An address string, bitcore address, or array of addresses
 * @param {Object} options
 * @param {Function} callback
 */
Bitcoin.prototype.getAddressSummary = function (addressArg, options, callback) {
    var self = this;
    var summary = {};
    var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;
    var summaryTxids = [];
    var mempoolTxids = [];
    var addresses = self._normalizeAddressArg(addressArg);
    var cacheKey = addresses.join('');

    function finishWithTxids() {
        if (!options.noTxList) {
            var allTxids = mempoolTxids.reverse().concat(summaryTxids);
            var fromArg = parseInt(options.from || 0);
            var toArg = parseInt(options.to || self.maxTxids);

            if ((toArg - fromArg) > self.maxTxids) {
                return callback(new Error(
                    '"from" (' + fromArg + ') and "to" (' + toArg + ') range should be less than or equal to ' +
                    self.maxTxids
                ));
            }
            var paginatedTxids;
            try {
                paginatedTxids = self._paginateTxids(allTxids, fromArg, toArg);
            } catch (e) {
                return callback(e);
            }

            var allSummary = _.clone(summary);
            allSummary.txids = paginatedTxids;
            callback(null, allSummary);
        } else {
            callback(null, summary);
        }
    }

    function querySummary() {
        async.parallel([
            function getTxList(done) {  //获取地址的交易列表
                if (options.assetsId && options.assetsId != "all") {
                    self.client.getaddrassettxids(addresses, options.assetsId, 1, function (err, txids) {
                        if (err) {
                            return done(err);
                        }
                        txids = txids.result.txList;
                        summaryTxids = txids;
                        summary.appearances = txids.length;
                        done();
                    })
                } else {
                    self.getAddressTxids(addresses, {queryMempool: false}, function (err, txids) {
                        if (err) {
                            return done(err);
                        }
                        summaryTxids = txids;
                        summary.appearances = txids.length;
                        done();
                    });
                }
            }, function getBalance(done) {  //获取地址余额，总接收，总发送，总锁定
                self.getAddressBalance(addresses, options, function (err, data) {
                    if (err) {
                        return done(err);
                    }
                    summary.balance = data.balance;     //总余额
                    summary.received = data.received;   //总接收
                    summary.lock = data.lock;           //总锁定
                    summary.depositAmount = data.depositAmount || 0 ;           //总封存
                    done();
                });
            }, function getMempool(done) {
                if (!queryMempool) {
                    return done();
                }
                self.client.getAddressMempool({'addresses': addresses}, function (err, response) {
                    if (err) {
                        return done(self._wrapRPCError(err));
                    }

                    mempoolTxids = self._getTxidsFromMempool(response.result);
                    summary.unconfirmedAppearances = mempoolTxids.length;
                    summary.unconfirmedBalance = self._getBalanceFromMempool(response.result);
                    done();
                });
            }
        ], function (err) {
            if (err) {
                log.error(`bitcoind.js-getAddressSummary(addressArg:${addressArg},options:${JSON.stringify(options)}) / error:${self._wrapRPCError(err)}`);
                return callback(err);
            }
            self.summaryCache.set(cacheKey, summary);
            finishWithTxids();
        });
    }

    if (options.noTxList) {
        var summaryCache = self.summaryCache.get(cacheKey);
        if (summaryCache) {
            callback(null, summaryCache);
        } else {
            querySummary();
        }
    } else {
        querySummary();
    }

};

Bitcoin.prototype._maybeGetBlockHash = function (blockArg, callback) {
    var self = this;
    if (_.isNumber(blockArg) || (blockArg && blockArg.length && blockArg.length < 40 && /^[0-9]+$/.test(blockArg))) {
        self._tryAllClients(function (client, done) {
            client.getBlockHash(blockArg, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                done(null, response.result);
            });
        }, callback);
    } else {
        callback(null, blockArg);
    }
};

/**
 * Will retrieve a block as a Node.js Buffer
 * @param {String|Number} blockArg - A block hash or block height number
 * @param {Function} callback
 */
Bitcoin.prototype.getRawBlock = function (blockArg, callback) {
    // TODO apply performance patch to the RPC method for raw data
    var self = this;

    function queryBlock(err, blockhash) {
        if (err) {
            return callback(err);
        }
        self._tryAllClients(function (client, done) {
            self.client.getBlock(blockhash, false, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                var buffer = new Buffer(response.result, 'hex');
                self.rawBlockCache.set(blockhash, buffer);
                done(null, buffer);
            });
        }, callback);
    }

    var cachedBlock = self.rawBlockCache.get(blockArg);
    if (cachedBlock) {
        return setImmediate(function () {
            callback(null, cachedBlock);
        });
    } else {
        self._maybeGetBlockHash(blockArg, queryBlock);
    }
};

/**
 * Similar to getBlockHeader but will include a list of txids
 * @param {String|Number} blockArg - A block hash or block height number
 * @param {Function} callback
 */
Bitcoin.prototype.getBlockOverview = function (blockArg, callback) {
    var self = this;

    function queryBlock(err, blockhash) {
        if (err) {
            return callback(err);
        }
        var cachedBlock = self.blockOverviewCache.get(blockhash);
        if (cachedBlock) {
            return setImmediate(function () {
                callback(null, cachedBlock);
            });
        } else {
            self._tryAllClients(function (client, done) {
                client.getBlock(blockhash, true, function (err, response) {
                    if (err) {
                        return done(self._wrapRPCError(err));
                    }
                    var result = response.result;
                    var blockOverview = {
                        hash: result.hash,
                        version: result.version,
                        confirmations: result.confirmations,
                        height: result.height,
                        chainWork: result.chainwork,
                        prevHash: result.previousblockhash,
                        nextHash: result.nextblockhash,
                        merkleRoot: result.merkleroot,
                        time: result.time,
                        medianTime: result.mediantime,
                        nonce: result.nonce,
                        bits: result.bits,
                        difficulty: result.difficulty,
                        txids: result.tx
                    };
                    self.blockOverviewCache.set(blockhash, blockOverview);
                    done(null, blockOverview);
                });
            }, callback);
        }
    }

    self._maybeGetBlockHash(blockArg, queryBlock);
};

/**
 * Will retrieve a block as a Bitcore object
 * @param {String|Number} blockArg - A block hash or block height number
 * @param {Function} callback
 */
Bitcoin.prototype.getBlock = function (blockArg, callback) {
    // TODO apply performance patch to the RPC method for raw data
    var self = this;

    function queryBlock(err, blockhash) {
        if (err) {
            return callback(err);
        }
        var cachedBlock = self.blockCache.get(blockhash);
        if (cachedBlock) {
            return setImmediate(function () {
                callback(null, cachedBlock);
            });
        } else {
            self._tryAllClients(function (client, done) {
                if (blockhash == null) {
                    return callback({code: -8, message: "block is undefined"});
                }
                client.getBlock(blockhash, true, function (err, response) {
                    if (err) {
                        return done(self._wrapRPCError(err));
                    }
                    var blockObj = response.result;
                    self.blockCache.set(blockhash, blockObj);
                    done(null, blockObj);
                });
            }, callback);
        }
    }

    self._maybeGetBlockHash(blockArg, queryBlock);
};

/**
 * Will retrieve an array of block hashes within a range of timestamps
 * @param {Number} high - The more recent timestamp in seconds
 * @param {Number} low - The older timestamp in seconds
 * @param {Function} callback
 */
Bitcoin.prototype.getBlockHashesByTimestamp = function (high, low, callback) {
    var self = this;
    self.client.getBlockHashes(high, low, function (err, response) {
        if (err) {
            log.error(`bitcoind.js-getBlockHashesByTimestamp(high:${high},low:${low}) / error:${self._wrapRPCError(err)}`);
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * Will return the block index information, the output will have the format:
 * {
 *   hash: '0000000000000a817cd3a74aec2f2246b59eb2cbb1ad730213e6c4a1d68ec2f6',
 *   confirmations: 5,
 *   height: 828781,
 *   chainWork: '00000000000000000000000000000000000000000000000ad467352c93bc6a3b',
 *   prevHash: '0000000000000504235b2aff578a48470dbf6b94dafa9b3703bbf0ed554c9dd9',
 *   nextHash: '00000000000000eedd967ec155f237f033686f0924d574b946caf1b0e89551b8'
 *   version: 536870912,
 *   merkleRoot: '124e0f3fb5aa268f102b0447002dd9700988fc570efcb3e0b5b396ac7db437a9',
 *   time: 1462979126,
 *   medianTime: 1462976771,
 *   nonce: 2981820714,
 *   bits: '1a13ca10',
 *   difficulty: 847779.0710240941,
 * }
 * @param {String|Number} blockArg - A block hash or block height
 * @param {Function} callback
 */
Bitcoin.prototype.getBlockHeader = function (blockArg, callback) {
    var self = this;

    function queryHeader(err, blockhash) {
        if (err) {
            return callback(err);
        }
        self._tryAllClients(function (client, done) {
            client.getBlockHeader(blockhash, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }

                var result = response.result;
                var header = {
                    hash: result.hash,
                    version: result.version,
                    confirmations: result.confirmations,
                    height: result.height,
                    chainWork: result.chainwork,
                    prevHash: result.previousblockhash,
                    nextHash: result.nextblockhash,
                    merkleRoot: result.merkleroot,
                    time: result.time,
                    medianTime: result.mediantime,
                    nonce: result.nonce,
                    bits: result.bits,
                    difficulty: result.difficulty
                };
                done(null, header);
            });
        }, callback);
    }

    self._maybeGetBlockHash(blockArg, queryHeader);
};

/**
 * Will estimate the fee per kilobyte.
 * @param {Number} blocks - The number of blocks for the transaction to be confirmed.
 * @param {Function} callback
 */
Bitcoin.prototype.estimateFee = function (blocks, callback) {
    var self = this;
    this.client.estimateFee(blocks, function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * Will add a transaction to the mempool and relay to connected peers
 * @param {String|Transaction} tx - The hex string of the transaction
 * @param {Object=} options
 * @param {Boolean=} options.allowAbsurdFees - Enable large fees
 * @param {{allowAbsurdFees?}} callback
 */
Bitcoin.prototype.sendTransaction = function (tx, options, callback) {
    var self = this;
    var allowAbsurdFees = false;
    if (_.isFunction(options) && _.isUndefined(callback)) {
        callback = options;
    } else if (_.isObject(options)) {
        allowAbsurdFees = options.allowAbsurdFees;
    }

    this.client.sendRawTransaction(tx, allowAbsurdFees, function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * Will get a transaction as a Node.js Buffer. Results include the mempool.
 * @param {String} txid - The transaction hash
 * @param {Function} callback
 */
Bitcoin.prototype.getRawTransaction = function (txid, callback) {
    var self = this;
    var tx = self.rawTransactionCache.get(txid);
    if (tx) {
        return setImmediate(function () {
            callback(null, tx);
        });
    } else {
        self._tryAllClients(function (client, done) {
            client.getRawTransaction(txid, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                var buffer = new Buffer(response.result, 'hex');
                self.rawTransactionCache.set(txid, buffer);
                done(null, response);
            });
        }, callback);
    }
};

/**
 * Will get a transaction as a Bitcore Transaction. Results include the mempool.
 * @param {String} txid - The transaction hash
 * @param {Function} callback
 */
Bitcoin.prototype.getTransaction = function (txid, callback) {
    var self = this;
    var tx = self.transactionCache.get(txid);
    if (tx) {
        return setImmediate(function () {
            callback(null, tx);
        });
    } else {
        self._tryAllClients(function (client, done) {
            client.getRawTransaction(txid, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                var tx = Transaction();
                tx.fromString(response.result);
                self.transactionCache.set(txid, tx);
                done(null, tx);
            });
        }, callback);
    }
};

/**
 * Will get a detailed view of a transaction including addresses, amounts and fees.
 *
 * Example result:
 *
 * @param {String} txid - The hex string of the transaction
 * @param {Function} callback
 */
Bitcoin.prototype.getDetailedTransaction = function (txid, callback) {
    var self = this;
    var tx = self.transactionDetailedCache.get(txid);

    function addInputsToTx(tx, result) {
        tx.inputs = [];
        for (var inputIndex = 0; inputIndex < result.vin.length; inputIndex++) {
            var input = result.vin[inputIndex];
            var script = null;
            var scriptAsm = null;
            if (input.scriptSig) {
                script = input.scriptSig.hex;
                scriptAsm = input.scriptSig.asm;
            } else if (input.coinbase) {
                script = input.coinbase;
            }
            tx.inputs.push({
                prevTxId: input.txid || null,
                outputIndex: _.isUndefined(input.vout) ? null : input.vout,
                script: script,
                scriptAsm: scriptAsm || null,
                sequence: input.sequence,
                address: input.addr || input.address || null,
                satoshis: _.isUndefined(input.value) ? null : input.value,
                is_asset: input.is_asset
            });
        }
    }

    function addOutputsToTx(tx, result) {
        tx.outputs = [];
        for (var outputIndex = 0; outputIndex < result.vout.length; outputIndex++) {
            var out = result.vout[outputIndex];
            var address = null;
            if (out.scriptPubKey && out.scriptPubKey.addresses && out.scriptPubKey.addresses.length === 1) {
                address = out.scriptPubKey.addresses[0];
            }
            tx.outputs.push({
                satoshis: out.value,
                script: out.scriptPubKey.hex,
                scriptAsm: out.scriptPubKey.asm,
                spentTxId: out.spentTxId, //not
                spentIndex: out.spentIndex,//not
                spentHeight: out.spentHeight,//not
                address: address,
                vReserve: out.reserve,
                nUnlockHeight: out.unlockedHeight,
                assetId: out.assetId
            });
        }

    }

    function addTxlockToTx(tx, result) {
        tx.txlock = false;
        if (tx.feeSatoshis >= Bitcoin.DEFAULT_INSTANTSEND_FEE) { // if transaction fee is >= 0.001 check for txlock
            var rawTx = new bitcore.Transaction(result.hex);
            var hash = bitcore.crypto.Hash.sha256sha256(rawTx.toBuffer());
            var id = hash.toString('binary');
            if (self.node.services.bitcoind.zmqKnownTransactionLocks.get(id)) {
                tx.txlock = true; // if "txlock" notification received through ZMQ, set txlock = true
            }
        }
    }

    if (tx) {
        return setImmediate(function () {
            callback(null, tx);
        });
    } else {
        self._tryAllClients(function (client, done) {
            client.getRawTransaction(txid, 1, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                var result = response.result;
                var tx = {
                    hex: result.hex,
                    blockHash: result.blockhash,
                    height: result.height ? result.height : -1,
                    blockTimestamp: result.time,
                    version: result.version,
                    hash: txid,
                    locktime: result.locktime
                };

                if (result.vin[0] && result.vin[0].coinbase) {
                    tx.coinbase = true;
                }

                addInputsToTx(tx, result);
                addOutputsToTx(tx, result);
                addTxlockToTx(tx, result);
                self.transactionDetailedCache.set(txid, tx);
                done(null, tx)
            });
        }, callback);
    }
};

/**
 * Returns a list of governance objects.
 * @param options - should be either "1" or "2", used to filter the object type
 * @param callback
 */
Bitcoin.prototype.govObjectList = function (options, callback) {
    var self = this;

    this.client.gobject('list', function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        var gobjects = Object.keys(response.result);
        var result = [];
        for (var i = 0; i < gobjects.length; i++) {
            var proposal = new Proposal(response.result[gobjects[i]].DataHex);
            if ((options.type && proposal.type === options.type)) {
                result.push({
                    Hash: gobjects[i],
                    DataHex: response.result.DataHex,
                    DataObject: {
                        end_epoch: proposal.end_epoch,
                        name: proposal.name,
                        payment_address: proposal.payment_address,
                        payment_amount: proposal.payment_amount,
                        start_epoch: proposal.start_epoch,
                        type: proposal.type,
                        url: proposal.url
                    },
                    AbsoluteYesCount: response.result[gobjects[i]].AbsoluteYesCount,
                    YesCount: response.result[gobjects[i]].YesCount,
                    NoCount: response.result[gobjects[i]].NoCount,
                    AbstainCount: response.result[gobjects[i]].AbstainCount
                });
            }
        }

        callback(null, result);

    });
};

/**
 * Retrieves a Governance Object by Hash
 * @param hash
 * @param callback
 */
Bitcoin.prototype.govObjectHash = function (hash, callback) {
    var self = this;

    this.client.gobject('get', hash, function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        var result = [];
        var proposal = new Proposal(response.result.DataHex);
        // TODO: serialize proposal back to Hex to verify it's consistent with RPC
        result.push({
            Hash: response.result.Hash,
            CollateralHash: response.result.CollateralHash,
            DataHex: response.result.DataHex,
            DataObject: {
                end_epoch: proposal.end_epoch,
                name: proposal.name,
                payment_address: proposal.payment_address,
                payment_amount: proposal.payment_amount,
                start_epoch: proposal.start_epoch,
                type: proposal.type,
                url: proposal.url
            },
            CreationTime: response.result.CreationTime,
            FundingResult: response.result.FundingResult,
            ValidResult: response.result.ValidResult,
            DeleteResult: response.result.DeleteResult,
            EndorsedResult: response.result.EndorsedResult
        });
        callback(null, result);
    });
};

/**
 * Will get the best block hash for the chain.
 * @param {Function} callback
 */
Bitcoin.prototype.getBestBlockHash = function (callback) {
    var self = this;
    this.client.getBestBlockHash(function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * Will give the txid and inputIndex that spent an output
 * @param options
 * @param {Function} callback
 */
Bitcoin.prototype.getSpentInfo = function (options, callback) {
    var self = this;
    this.client.getSpentInfo(options, function (err, response) {
        if (err && err.code === -5) {
            return callback(null, {});
        } else if (err) {
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * This will return information about the database in the format:
 * {
 *   version: 110000,
 *   protocolVersion: 70002,
 *   blocks: 151,
 *   timeOffset: 0,
 *   connections: 0,
 *   difficulty: 4.6565423739069247e-10,
 *   testnet: false,
 *   network: 'testnet'
 *   relayFee: 1000,
 *   errors: ''
 * }
 * @param {Function} callback
 */
Bitcoin.prototype.getInfo = function (callback) {
    var self = this;
    this.client.getInfo(function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        var result = response.result;
        var info = {
            version: result.version,
            protocolVersion: result.protocolversion,
            blocks: result.blocks,
            timeOffset: result.timeoffset,
            connections: result.connections,
            proxy: result.proxy,
            difficulty: result.difficulty,
            testnet: result.testnet,
            relayFee: result.relayfee,
            errors: result.errors,
            network: self.node.getNetworkName()
        };
        callback(null, info);
    });
};

Bitcoin.prototype.generateBlock = function (num, callback) {
    var self = this;
    this.client.generate(num, function (err, response) {
        if (err) {
            return callback(self._wrapRPCError(err));
        }
        callback(null, response.result);
    });
};

/**
 * Called by Node to stop the service.
 * @param {Function} callback
 */
Bitcoin.prototype.stop = function (callback) {
    if (this.spawn && this.spawn.process) {
        var exited = false;
        this.spawn.process.once('exit', function (code) {
            if (!exited) {
                exited = true;
                if (code !== 0) {
                    var error = new Error('safed spawned process exited with status code: ' + code);
                    error.code = code;
                    return callback(error);
                } else {
                    return callback();
                }
            }
        });
        this.spawn.process.kill('SIGINT');
        setTimeout(function () {
            if (!exited) {
                exited = true;
                return callback(new Error('safed process did not exit'));
            }
        }, this.shutdownTimeout).unref();
    } else {
        callback();
    }
};

/**
 * 根据区块高度获取区块详情
 * @param height
 * @param callback
 */
Bitcoin.prototype.getBlockByNumber = function (height, callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        self.client.getblockhash(height, function (err, response) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            self.client.getblock(response.result, function (err, block) {
                done(null, block);
            })
        });
    }, callback);
};

/**
 * 根据交易ID获取交易详情，未处理过的数据
 * @param txid
 * @param callback
 * @return {*}
 */
Bitcoin.prototype.getRawTransactionJson = function (txid, callback) {
    var self = this;
    var tx = self.rawTransactionCache.get(txid);
    if (tx) {
        return setImmediate(function () {
            callback(null, tx);
        });
    } else {
        self._tryAllClients(function (client, done) {
            client.getRawTransaction(txid, 1, function (err, response) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                done(null, response.result);
            });
        }, callback);
    }
};

/**
 *  根据资产ID获取资产详情
 *  @parmas id
 *  @return assetsObject
 */
Bitcoin.prototype.getAssetsObj = function (assetsId, callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.getassetinfo(assetsId, function (err, assetsDetail) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            callback(null, assetsDetail.result);
        });
    }, callback);
};

/**
 * 获取资产ID 列表
 * @param callback
 */
Bitcoin.prototype.getAssetsList = function (callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.getassetlist(function (err, response) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            callback(null, response.result.assetList)
        });
    }, callback);
};

Bitcoin.prototype.getAssetsListOld = function (page, callback) {
    var self = this;
    var assets = {};
    assets.list = [];
    var list = [];
    self._tryAllClients(function (client, done) {
        client.getassetlist(function (err, response) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            var assetList = response.result.assetList;
            for (var i = (page - 1) * 10; i < page * 10; i++) {
                if (assetList[i]) {
                    list.push(assetList[i]);
                }
            }
            async.eachSeries(list, function (assetId, callback) {
                self.getAssetsObj(assetId, function (err, assetDetail) {
                    if (err) {
                        log.info("get assets list detail err : " + err);
                        if (err.code == -620) {
                            return callback(null)
                        }
                        callback(err);
                    }
                    assets.list.push({
                        assetId: assetId,                                   //资产ID
                        assetShortName: assetDetail.assetShortName,          //资产短名称
                        assetName: assetDetail.assetName,                    //资产名称
                        assetTotalAmount: assetDetail.assetTotalAmount,      //发行总量
                        alreadyIssueAmount: assetDetail.alreadyIssueAmount,  //已发行量
                        issueTime: assetDetail.issuetime  //发行时间
                    });
                    callback(null);
                })
            }, function (err) {
                if (err) {
                    callback(err);
                }
                assets.more = assetList.length / 10 > page;
                assets.maxPage = Math.ceil(assetList.length / 10);
                callback(null, assets);
            })
        });
    }, callback);
};

/**
 * 根据资产ID获取资产发布和追加发布的交易ID
 * @param assetsid
 * @param page
 * @param callback
 * @return assets transaction list
 */
Bitcoin.prototype.getAssetsTxList = function (assetsid, page, callback) {
    var self = this;
    var result = {
        count: 1,
        txids: []
    };
    self._tryAllClients(function (client, done) {
        client.getassetidtxids(assetsid, 5, function (err, assetTxIdList) { // 获取追加发布资产的交易列表
            if (err) {
                if (err.code == -525) {
                    if (page != 1) {
                        return callback(null, result);
                    }
                } else {
                    return done(self._wrapRPCError(err));
                }
            } else {
                assetTxIdList = assetTxIdList.result.txList;
                var startIndex = page * 10 - 11;
                result = {
                    count: assetTxIdList.length + 1,
                    txids: assetTxIdList.slice(startIndex < 0 ? 0 : startIndex, page * 10 - 1)
                }
            }
            if (page == 1) {  //如果是第一页，需要加入发布资产信息
                client.getassetidtxids(assetsid, 4, function (err, assetTxIdList) { // 获取追加发布资产的交易列表
                    if (err) {
                        return done(self._wrapRPCError(err));
                    }
                    result.txids.unshift(assetTxIdList.result.txList[0]);
                    callback(null, result);
                });
            } else {
                callback(null, result);
            }
        });
    }, callback)
};

/**
 * 根据资产ID获取资产所有的交易ID
 * @param assetsid
 * @param page
 * @param callback
 * @return assets transaction list
 */
Bitcoin.prototype.getAssetsTxAllList = function (assetsid, page, callback) {
    var self = this;
    var result = {
        count: 1,
        txids: []
    };
    self._tryAllClients(function (client, done) {
        client.getassetidtxids(assetsid, 1, function (err, assetTxIdList) { // 获取追加发布资产的交易列表
            if (err) {
                return done(self._wrapRPCError(err));
            } else {
                assetTxIdList = assetTxIdList.result.txList.reverse();
                var startIndex = page * 10 - 10;
                result = {
                    count: assetTxIdList.length,
                    txids: assetTxIdList.slice(startIndex < 0 ? 0 : startIndex, page * 10)
                };
                callback(null, result);
            }
        });
    }, callback)
};

/**
 * 得到主节点信息
 * @param callback
 * @return masternode list
 */
Bitcoin.prototype.getMasterNode = function (callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.masternodelist("full", "", function (err, nodeList) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            callback(null, nodeList.result);
        });
    }, callback);
};

/**
 * 得到主节点 正常状态下 节点的比例
 *
 * @param callback
 */
Bitcoin.prototype.getMasterNodeRate = function (callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.masternode("count", function (err, all) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            client.masternodelist("status", 'ENABLED', function (err, enabled) {
                if (err) {
                    return done(self._wrapRPCError(err));
                }
                var enabledKeys = Object.keys(enabled.result);
                // client.masternodelist("status", 'PRE_EANBLED', function (err, per_enabled) {
                //     if (err) {
                //         return done(self._wrapRPCError(err));
                //     }
                //     var per_enabledKeys = Object.keys(per_enabled.result);
                //     callback(enabledKeys.length + per_enabledKeys.length, all.result);
                // });
                callback(enabledKeys.length, all.result);
            });
        });
    }, callback);
};

/**
 * 获取各个主节点状态的统计比例
 */
Bitcoin.prototype.getMasterNodeRateCount = function( callback ){
    var self = this;
    self._tryAllClients(function (client, done) {
        client.masternodelist( function (err, all) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            var masternodeList = all.result;
            var rateCount = {};
            for( var key in masternodeList ){
                var status = masternodeList[ key ];
                if ( ! rateCount[ status ] ){
                    rateCount[ status ] = 1;
                }else{
                    rateCount[ status ] ++ ;
                }
            }
            callback( rateCount );
        });
    }, callback);
}

/**
 * 获取地址交易过的资产类型
 * @param address
 * @param callback
 */
Bitcoin.prototype.getAddressAssetList = function (address, callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.getassetlistbyaddress(address, function (err, assetIds) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            callback(null, assetIds.result.assetList);
        });
    }, callback);
};

/**
 * 根据地址和资产ID获取 地址的资产交易列表
 * @param address
 * @param assetId
 * @param callback
 */
Bitcoin.prototype.getAddressAssetsTransactionList = function (address, assetId, callback) {
    var self = this;
    self._tryAllClients(function (client, done) {
        client.getaddrassettxids(address, assetId, 1, function (err, assetIds) {
            if (err) {
                return done(self._wrapRPCError(err));
            }
            callback(null, assetIds.result.txList);
        });
    }, callback);
};

/**
 * 根据页数返回地址相应的数据和总条数
 * @param option
 * @param cb
 */
Bitcoin.prototype.getLockedAddressList = function (option, cb) {
    var self = this;
    option.unlockedHeight = currHeight;
    if (option.assetName == "safe") {
        DB.getAddressLockedTotal(option, function (err, list) {
            if (err) {
                return cb(self._wrapRPCError(err));
            }
            DB.getAddressCount(option, function (err, count) {
                if (err) {
                    return cb(self._wrapRPCError(err));
                }
                cb(null, {list: list, count: count[0].count})
            })
        });
    } else {
        DB.getAssetLockedTotalForAssetName(option, function (err, list) {
            if (err) {
                return cb(self._wrapRPCError(err));
            }
            DB.getAddressCount(option, function (err, count) {
                if (err) {
                    return cb(self._wrapRPCError(err));
                }
                cb(null, {list: list, count: count[0].count})
            })
        })
    }
};

/**
 * 根据页数返回交易相应的数据和总条数
 * @param option
 * @param cb
 */
Bitcoin.prototype.getLockedTransactionList = function (option, cb) {
    var self = this;
    option.unlockedHeight = currHeight;
    if (option.assetName == "safe") {
        DB.getTransactionLockedTotal(option, function (err, list) {
            if (err) {
                return cb(self._wrapRPCError(err));
            }
            DB.getTransactionCount(option, function (err, count) {
                if (err) {
                    return cb(self._wrapRPCError(err));
                }
                cb(null, {list: list, count: count[0].count})
            })
        });
    } else {
        DB.getTransactionLockedTotalForAssetName(option, function (err, list) {
            if (err) {
                return cb(self._wrapRPCError(err));
            }
            DB.getTransactionCount(option, function (err, count) {
                if (err) {
                    return cb(self._wrapRPCError(err));
                }
                cb(null, {list: list, count: count[0].count})
            })
        });
    }
};

/**
 * 获取资产锁定的总金额 包括safe
 * @param assetName
 * @param cb
 */
Bitcoin.prototype.getAssetLockedTotalAmount = function (assetName, cb) {
    var self = this;
    var option = {
        assetName: assetName,
        unlockedHeight: currHeight
    };
    DB.getTotalLockedAmountForAssetName(option, function (err, result) {
        if (err) {
            return cb(self._wrapRPCError(err));
        }
        cb(null, result[0].totalLocked);
    })
};

/**
 * 返回锁定资产的名称
 * @param name
 * @param cb
 */
Bitcoin.prototype.getLockedAssetNameForMysql = function (name, cb) {
    var self = this;
    DB.getAssetNameByShortName(name, function (err, result) {
        if (err) {
            return cb(self._wrapRPCError(err));
        }
        cb(null, result);
    })
};

/**
 * 获取地址的锁定交易信息
 * @param option
 * @param cb
 */
Bitcoin.prototype.lockedDetailByAddressBit = function (option, cb) {
    var self = this;
    option.unlockedHeight = currHeight;
    if (option.assetName == "safe") {
        option.tableName = "lockedAddresses";
        option.where = "";
    } else {
        option.tableName = "lockedAssetAddress";
        option.where = " AND assetName = '" + option.assetName + "'";
    }
    DB.LockedDetailByAddressDB(option, function (err, list) {
        if (err) {
            return cb(self._wrapRPCError(err));
        }
        DB.LockedDetailByAddressCountDB(option, function (err, count) {
            if (err) {
                return cb(self._wrapRPCError(err));
            }
            cb(null, {list: list, count: count[0].count})
        })
    })
};

/**
 * 判断封存
 */
Bitcoin.prototype.isDepositFlag = function () {
    var self = this;
    currHeight++; //当前高度自增，用于之后解锁高度
    if (!self.depositFlag) {   //如果封存标志没有开启执行，判断是否开启封存标志
        if (currHeight >= bitcore.depositConf.beginHeight) { // 如果当前高度达到封存开始高度
            self.depositFlag = true;         //开启封存标志
        }
    }
};

/**
 * 如果达到封存高度返回封存状态(true)和需要封存的高度
 * 否则只返回封存状态 (false)
 * @param cb
 */
Bitcoin.prototype.getDepositFlag = function (cb) {
    if (this.depositFlag == true) {
        cb(this.depositFlag, bitcore.depositConf.beforeHeight);
    } else {
        cb(this.depositFlag);
    }
};

/**
 * 获取锁定数据
 * @param params
 * @param cb
 */
Bitcoin.prototype.getAddressList = function (params, cb) {
    DB.getAddressListForDate(params, function (err, list) {
        if (err) {
            return cb(err);
        }
        cb(null, list);
    })
};


/**
 * 获取资产排名数据
 * @param {*} params 
 * @param {*} cb 
 */
Bitcoin.prototype.getBalanceRanking = function( params , cb ){
    DB.getBalanceRanking( params , function( err , list ){
        if ( err ){
            return cb( err );
        }
        cb( null , list )
    } )
}

/**
 * 获取金额相关统计数据
 */
Bitcoin.prototype.getAmountStatistic = function( cb ){
    DB.getBlockAmountStatistic( function( err , result ){
        if ( err ){
            return cb( err );
        }
        cb( null , result )
    } )
}

Bitcoin.prototype.getStatistic = function( cb ){
    DB.getStatistic( function( err, result ){
        if ( err ){
            return cb( err );
        }
        cb( null , result )
    } );
}

Bitcoin.prototype.getTop100 = function( cb ){
    DB.getTop100( function( err, result ){
        if ( err ){
            return cb( err );
        }
        cb( null , result )
    } );
}

Bitcoin.prototype.getSeedAddress = function( cb ){
    DB.getSeedAddress( function( err, result ){
        if ( err ){
            return cb( err );
        }
        cb( null , result )
    } );
}

Bitcoin.prototype.getVpnAddress = function( cb ){
    SAFE_API_DB.getVpnAddress( function( err, result ){
        if ( err ){
            return cb( err );
        }
        cb( null , result )
    } );
}

module.exports = Bitcoin;
